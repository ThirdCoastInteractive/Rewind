// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ui_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"thirdcoast.systems/rewind/pkg/videoinfo"
)

const getDownloadJobByID = `-- name: GetDownloadJobByID :one
SELECT id, created_at, updated_at, url, archived_by, status, attempts, last_error, started_at, finished_at, spool_dir, info_json_path, video_id, refresh, process_pid, archived, extra_args
FROM download_jobs
WHERE id = $1
`

// GetDownloadJobByID returns a download job by ID
//
//	SELECT id, created_at, updated_at, url, archived_by, status, attempts, last_error, started_at, finished_at, spool_dir, info_json_path, video_id, refresh, process_pid, archived, extra_args
//	FROM download_jobs
//	WHERE id = $1
func (q *Queries) GetDownloadJobByID(ctx context.Context, id pgtype.UUID) (*DownloadJob, error) {
	row := q.db.QueryRow(ctx, getDownloadJobByID, id)
	var i DownloadJob
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.URL,
		&i.ArchivedBy,
		&i.Status,
		&i.Attempts,
		&i.LastError,
		&i.StartedAt,
		&i.FinishedAt,
		&i.SpoolDir,
		&i.InfoJsonPath,
		&i.VideoID,
		&i.Refresh,
		&i.ProcessPid,
		&i.Archived,
		&i.ExtraArgs,
	)
	return &i, err
}

const getVideoByID = `-- name: GetVideoByID :one
SELECT id, created_at, updated_at, src, archived_by, title, info, comments, video_path, thumbnail_path, description, tags, uploader, uploader_id, channel_id, upload_date, duration_seconds, view_count, like_count, thumb_gradient_start, thumb_gradient_end, thumb_gradient_angle, file_hash, file_size, assets_status, search, probe_data
FROM videos
WHERE id = $1
`

// GetVideoByID returns a video by ID
//
//	SELECT id, created_at, updated_at, src, archived_by, title, info, comments, video_path, thumbnail_path, description, tags, uploader, uploader_id, channel_id, upload_date, duration_seconds, view_count, like_count, thumb_gradient_start, thumb_gradient_end, thumb_gradient_angle, file_hash, file_size, assets_status, search, probe_data
//	FROM videos
//	WHERE id = $1
func (q *Queries) GetVideoByID(ctx context.Context, id pgtype.UUID) (*Video, error) {
	row := q.db.QueryRow(ctx, getVideoByID, id)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Src,
		&i.ArchivedBy,
		&i.Title,
		&i.Info,
		&i.Comments,
		&i.VideoPath,
		&i.ThumbnailPath,
		&i.Description,
		&i.Tags,
		&i.Uploader,
		&i.UploaderID,
		&i.ChannelID,
		&i.UploadDate,
		&i.DurationSeconds,
		&i.ViewCount,
		&i.LikeCount,
		&i.ThumbGradientStart,
		&i.ThumbGradientEnd,
		&i.ThumbGradientAngle,
		&i.FileHash,
		&i.FileSize,
		&i.AssetsStatus,
		&i.Search,
		&i.ProbeData,
	)
	return &i, err
}

const listDistinctTags = `-- name: ListDistinctTags :many
SELECT DISTINCT unnest(tags) AS tag
FROM videos
WHERE tags IS NOT NULL AND array_length(tags, 1) > 0
ORDER BY tag ASC
LIMIT 200
`

// ListDistinctTags returns unique tags for filter dropdown
//
//	SELECT DISTINCT unnest(tags) AS tag
//	FROM videos
//	WHERE tags IS NOT NULL AND array_length(tags, 1) > 0
//	ORDER BY tag ASC
//	LIMIT 200
func (q *Queries) ListDistinctTags(ctx context.Context) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, listDistinctTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var tag interface{}
		if err := rows.Scan(&tag); err != nil {
			return nil, err
		}
		items = append(items, tag)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDistinctUploaders = `-- name: ListDistinctUploaders :many
SELECT DISTINCT uploader
FROM videos
WHERE uploader IS NOT NULL AND uploader != ''
ORDER BY uploader ASC
LIMIT 100
`

// ListDistinctUploaders returns unique uploader names for filter dropdown
//
//	SELECT DISTINCT uploader
//	FROM videos
//	WHERE uploader IS NOT NULL AND uploader != ''
//	ORDER BY uploader ASC
//	LIMIT 100
func (q *Queries) ListDistinctUploaders(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, listDistinctUploaders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var uploader string
		if err := rows.Scan(&uploader); err != nil {
			return nil, err
		}
		items = append(items, uploader)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDownloadJobsByUser = `-- name: ListDownloadJobsByUser :many
SELECT id, created_at, updated_at, url, archived_by, status, attempts, last_error, started_at, finished_at, spool_dir, info_json_path, video_id, refresh, process_pid, archived, extra_args
FROM download_jobs
WHERE archived_by = $1
  AND archived = FALSE
ORDER BY created_at DESC
LIMIT $2
`

type ListDownloadJobsByUserParams struct {
	ArchivedBy pgtype.UUID `db:"archived_by" json:"ArchivedBy"`
	PageLimit  int32       `db:"page_limit" json:"PageLimit"`
}

// ListDownloadJobsByUser returns all download jobs for a user
//
//	SELECT id, created_at, updated_at, url, archived_by, status, attempts, last_error, started_at, finished_at, spool_dir, info_json_path, video_id, refresh, process_pid, archived, extra_args
//	FROM download_jobs
//	WHERE archived_by = $1
//	  AND archived = FALSE
//	ORDER BY created_at DESC
//	LIMIT $2
func (q *Queries) ListDownloadJobsByUser(ctx context.Context, arg *ListDownloadJobsByUserParams) ([]*DownloadJob, error) {
	rows, err := q.db.Query(ctx, listDownloadJobsByUser, arg.ArchivedBy, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DownloadJob
	for rows.Next() {
		var i DownloadJob
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.URL,
			&i.ArchivedBy,
			&i.Status,
			&i.Attempts,
			&i.LastError,
			&i.StartedAt,
			&i.FinishedAt,
			&i.SpoolDir,
			&i.InfoJsonPath,
			&i.VideoID,
			&i.Refresh,
			&i.ProcessPid,
			&i.Archived,
			&i.ExtraArgs,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDownloadJobsByVideoID = `-- name: ListDownloadJobsByVideoID :many
SELECT id, created_at, updated_at, url, archived_by, status, attempts, last_error, started_at, finished_at, spool_dir, info_json_path, video_id, refresh, process_pid, archived, extra_args
FROM download_jobs
WHERE video_id = $1
   OR url = $2
ORDER BY created_at DESC
`

type ListDownloadJobsByVideoIDParams struct {
	VideoID  pgtype.UUID `db:"video_id" json:"VideoID"`
	VideoSrc string      `db:"video_src" json:"VideoSrc"`
}

// ListDownloadJobsByVideoID returns all download jobs for a video.
// Matches by video_id FK or by URL matching the video's src column.
//
//	SELECT id, created_at, updated_at, url, archived_by, status, attempts, last_error, started_at, finished_at, spool_dir, info_json_path, video_id, refresh, process_pid, archived, extra_args
//	FROM download_jobs
//	WHERE video_id = $1
//	   OR url = $2
//	ORDER BY created_at DESC
func (q *Queries) ListDownloadJobsByVideoID(ctx context.Context, arg *ListDownloadJobsByVideoIDParams) ([]*DownloadJob, error) {
	rows, err := q.db.Query(ctx, listDownloadJobsByVideoID, arg.VideoID, arg.VideoSrc)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DownloadJob
	for rows.Next() {
		var i DownloadJob
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.URL,
			&i.ArchivedBy,
			&i.Status,
			&i.Attempts,
			&i.LastError,
			&i.StartedAt,
			&i.FinishedAt,
			&i.SpoolDir,
			&i.InfoJsonPath,
			&i.VideoID,
			&i.Refresh,
			&i.ProcessPid,
			&i.Archived,
			&i.ExtraArgs,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIngestJobsByDownloadJobIDs = `-- name: ListIngestJobsByDownloadJobIDs :many
SELECT id, created_at, updated_at, download_job_id, status, attempts, last_error, started_at, finished_at, asset_scope
FROM ingest_jobs
WHERE download_job_id = ANY($1::uuid[])
ORDER BY created_at DESC
`

// ListIngestJobsByDownloadJobIDs returns ingest jobs for a set of download job IDs.
//
//	SELECT id, created_at, updated_at, download_job_id, status, attempts, last_error, started_at, finished_at, asset_scope
//	FROM ingest_jobs
//	WHERE download_job_id = ANY($1::uuid[])
//	ORDER BY created_at DESC
func (q *Queries) ListIngestJobsByDownloadJobIDs(ctx context.Context, downloadJobIds []pgtype.UUID) ([]*IngestJob, error) {
	rows, err := q.db.Query(ctx, listIngestJobsByDownloadJobIDs, downloadJobIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*IngestJob
	for rows.Next() {
		var i IngestJob
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DownloadJobID,
			&i.Status,
			&i.Attempts,
			&i.LastError,
			&i.StartedAt,
			&i.FinishedAt,
			&i.AssetScope,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentDownloadJobs = `-- name: ListRecentDownloadJobs :many
SELECT id, created_at, updated_at, url, archived_by, status, attempts, last_error, started_at, finished_at, spool_dir, info_json_path, video_id, refresh, process_pid, archived, extra_args
FROM download_jobs
WHERE archived = FALSE
ORDER BY created_at DESC
LIMIT 100
`

// ListRecentDownloadJobs returns recent download jobs for all users
//
//	SELECT id, created_at, updated_at, url, archived_by, status, attempts, last_error, started_at, finished_at, spool_dir, info_json_path, video_id, refresh, process_pid, archived, extra_args
//	FROM download_jobs
//	WHERE archived = FALSE
//	ORDER BY created_at DESC
//	LIMIT 100
func (q *Queries) ListRecentDownloadJobs(ctx context.Context) ([]*DownloadJob, error) {
	rows, err := q.db.Query(ctx, listRecentDownloadJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DownloadJob
	for rows.Next() {
		var i DownloadJob
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.URL,
			&i.ArchivedBy,
			&i.Status,
			&i.Attempts,
			&i.LastError,
			&i.StartedAt,
			&i.FinishedAt,
			&i.SpoolDir,
			&i.InfoJsonPath,
			&i.VideoID,
			&i.Refresh,
			&i.ProcessPid,
			&i.Archived,
			&i.ExtraArgs,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentVideos = `-- name: ListRecentVideos :many
SELECT id, created_at, updated_at, src, archived_by, title, info, comments, video_path, thumbnail_path, description, tags, uploader, uploader_id, channel_id, upload_date, duration_seconds, view_count, like_count, thumb_gradient_start, thumb_gradient_end, thumb_gradient_angle, file_hash, file_size, assets_status, search, probe_data
FROM videos
ORDER BY created_at DESC
LIMIT 10
`

// ListRecentVideos returns recent videos
//
//	SELECT id, created_at, updated_at, src, archived_by, title, info, comments, video_path, thumbnail_path, description, tags, uploader, uploader_id, channel_id, upload_date, duration_seconds, view_count, like_count, thumb_gradient_start, thumb_gradient_end, thumb_gradient_angle, file_hash, file_size, assets_status, search, probe_data
//	FROM videos
//	ORDER BY created_at DESC
//	LIMIT 10
func (q *Queries) ListRecentVideos(ctx context.Context) ([]*Video, error) {
	rows, err := q.db.Query(ctx, listRecentVideos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Video
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Src,
			&i.ArchivedBy,
			&i.Title,
			&i.Info,
			&i.Comments,
			&i.VideoPath,
			&i.ThumbnailPath,
			&i.Description,
			&i.Tags,
			&i.Uploader,
			&i.UploaderID,
			&i.ChannelID,
			&i.UploadDate,
			&i.DurationSeconds,
			&i.ViewCount,
			&i.LikeCount,
			&i.ThumbGradientStart,
			&i.ThumbGradientEnd,
			&i.ThumbGradientAngle,
			&i.FileHash,
			&i.FileSize,
			&i.AssetsStatus,
			&i.Search,
			&i.ProbeData,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideosPaginated = `-- name: ListVideosPaginated :many
SELECT 
    v.id, v.created_at, v.updated_at, v.src, v.archived_by, v.title, v.info, v.comments, v.video_path, v.thumbnail_path, v.description, v.tags, v.uploader, v.uploader_id, v.channel_id, v.upload_date, v.duration_seconds, v.view_count, v.like_count, v.thumb_gradient_start, v.thumb_gradient_end, v.thumb_gradient_angle, v.file_hash, v.file_size, v.assets_status, v.search, v.probe_data,
    COUNT(*) OVER() AS total_count,
    COALESCE((SELECT COUNT(*) FROM clips c WHERE c.video_id = v.id), 0) AS clip_count,
    COALESCE((SELECT COUNT(*) FROM markers m WHERE m.video_id = v.id), 0) AS marker_count,
    COALESCE((SELECT MAX(c.created_at) FROM clips c WHERE c.video_id = v.id), '1970-01-01'::timestamptz) AS last_clip_at,
    COALESCE((SELECT MAX(m.created_at) FROM markers m WHERE m.video_id = v.id), '1970-01-01'::timestamptz) AS last_marker_at,
    COALESCE(u.user_name, 'unknown') AS archived_by_username
FROM videos v
LEFT JOIN users u ON v.archived_by = u.id
WHERE
    -- Full-text search (optional)
    ($1::text IS NULL OR v.search @@ plainto_tsquery('simple', $1))
    -- Uploader filter (optional)
    AND ($2::text IS NULL OR v.uploader = $2)
    -- Channel filter (optional)
    AND ($3::text IS NULL OR v.channel_id = $3)
    -- Duration filter: short=<5min, medium=5-30min, long=>30min
    AND (
        $4::text IS NULL
        OR ($4 = 'short' AND v.duration_seconds < 300)
        OR ($4 = 'medium' AND v.duration_seconds >= 300 AND v.duration_seconds < 1800)
        OR ($4 = 'long' AND v.duration_seconds >= 1800)
    )
    -- Tags filter (any tag matches)
    AND ($5::text[] IS NULL OR v.tags && $5::text[])
    -- Date range (archived or published based on date_type)
    AND (
        $6::date IS NULL 
        OR ($7::text = 'published' AND v.upload_date >= $6)
        OR ($7::text IS DISTINCT FROM 'published' AND v.created_at::date >= $6)
    )
    AND (
        $8::date IS NULL
        OR ($7::text = 'published' AND v.upload_date <= $8)
        OR ($7::text IS DISTINCT FROM 'published' AND v.created_at::date <= $8)
    )
    -- Has clips filter
    AND ($9::boolean IS NULL OR $9 = FALSE 
         OR EXISTS (SELECT 1 FROM clips c WHERE c.video_id = v.id))
    -- Has markers filter
    AND ($10::boolean IS NULL OR $10 = FALSE
         OR EXISTS (SELECT 1 FROM markers m WHERE m.video_id = v.id))
ORDER BY
    -- Date sorts (archived)
    CASE WHEN $11 = 'newest' THEN v.created_at END DESC NULLS LAST,
    CASE WHEN $11 = 'oldest' THEN v.created_at END ASC NULLS LAST,
    -- Date sorts (published)
    CASE WHEN $11 = 'published-newest' THEN v.upload_date END DESC NULLS LAST,
    CASE WHEN $11 = 'published-oldest' THEN v.upload_date END ASC NULLS LAST,
    -- Title sorts
    CASE WHEN $11 = 'alpha' THEN v.title END ASC NULLS LAST,
    CASE WHEN $11 = 'alpha-desc' THEN v.title END DESC NULLS LAST,
    -- Duration sorts
    CASE WHEN $11 = 'duration' THEN v.duration_seconds END ASC NULLS LAST,
    CASE WHEN $11 = 'duration-desc' THEN v.duration_seconds END DESC NULLS LAST,
    -- Activity sorts
    CASE WHEN $11 = 'most-clips' THEN (SELECT COUNT(*) FROM clips c WHERE c.video_id = v.id) END DESC NULLS LAST,
    CASE WHEN $11 = 'most-markers' THEN (SELECT COUNT(*) FROM markers m WHERE m.video_id = v.id) END DESC NULLS LAST,
    CASE WHEN $11 = 'recently-clipped' THEN (SELECT MAX(c.created_at) FROM clips c WHERE c.video_id = v.id) END DESC NULLS LAST,
    CASE WHEN $11 = 'recently-marked' THEN (SELECT MAX(m.created_at) FROM markers m WHERE m.video_id = v.id) END DESC NULLS LAST,
    -- Default fallback
    v.created_at DESC
LIMIT $13
OFFSET $12
`

type ListVideosPaginatedParams struct {
	Query          *string     `db:"query" json:"Query"`
	Uploader       *string     `db:"uploader" json:"Uploader"`
	ChannelID      *string     `db:"channel_id" json:"ChannelID"`
	DurationFilter *string     `db:"duration_filter" json:"DurationFilter"`
	Tags           []string    `db:"tags" json:"Tags"`
	DateFrom       pgtype.Date `db:"date_from" json:"DateFrom"`
	DateType       *string     `db:"date_type" json:"DateType"`
	DateTo         pgtype.Date `db:"date_to" json:"DateTo"`
	HasClips       *bool       `db:"has_clips" json:"HasClips"`
	HasMarkers     *bool       `db:"has_markers" json:"HasMarkers"`
	SortOrder      interface{} `db:"sort_order" json:"SortOrder"`
	PageOffset     int32       `db:"page_offset" json:"PageOffset"`
	PageLimit      int32       `db:"page_limit" json:"PageLimit"`
}

type ListVideosPaginatedRow struct {
	ID                 pgtype.UUID          `db:"id" json:"ID"`
	CreatedAt          pgtype.Timestamptz   `db:"created_at" json:"CreatedAt"`
	UpdatedAt          pgtype.Timestamptz   `db:"updated_at" json:"UpdatedAt"`
	Src                string               `db:"src" json:"Src"`
	ArchivedBy         pgtype.UUID          `db:"archived_by" json:"ArchivedBy"`
	Title              string               `db:"title" json:"Title"`
	Info               videoinfo.VideoInfo  `db:"info" json:"Info"`
	Comments           []byte               `db:"comments" json:"Comments"`
	VideoPath          *string              `db:"video_path" json:"VideoPath"`
	ThumbnailPath      *string              `db:"thumbnail_path" json:"ThumbnailPath"`
	Description        string               `db:"description" json:"Description"`
	Tags               []string             `db:"tags" json:"Tags"`
	Uploader           string               `db:"uploader" json:"Uploader"`
	UploaderID         *string              `db:"uploader_id" json:"UploaderID"`
	ChannelID          *string              `db:"channel_id" json:"ChannelID"`
	UploadDate         pgtype.Date          `db:"upload_date" json:"UploadDate"`
	DurationSeconds    *int32               `db:"duration_seconds" json:"DurationSeconds"`
	ViewCount          *int64               `db:"view_count" json:"ViewCount"`
	LikeCount          *int64               `db:"like_count" json:"LikeCount"`
	ThumbGradientStart *string              `db:"thumb_gradient_start" json:"ThumbGradientStart"`
	ThumbGradientEnd   *string              `db:"thumb_gradient_end" json:"ThumbGradientEnd"`
	ThumbGradientAngle *int32               `db:"thumb_gradient_angle" json:"ThumbGradientAngle"`
	FileHash           *string              `db:"file_hash" json:"FileHash"`
	FileSize           *int64               `db:"file_size" json:"FileSize"`
	AssetsStatus       AssetMap             `db:"assets_status" json:"AssetsStatus"`
	Search             string               `db:"search" json:"Search"`
	ProbeData          *videoinfo.ProbeInfo `db:"probe_data" json:"ProbeData"`
	TotalCount         int64                `db:"total_count" json:"TotalCount"`
	ClipCount          interface{}          `db:"clip_count" json:"ClipCount"`
	MarkerCount        interface{}          `db:"marker_count" json:"MarkerCount"`
	LastClipAt         interface{}          `db:"last_clip_at" json:"LastClipAt"`
	LastMarkerAt       interface{}          `db:"last_marker_at" json:"LastMarkerAt"`
	ArchivedByUsername string               `db:"archived_by_username" json:"ArchivedByUsername"`
}

// ListVideosPaginated returns videos with filters, sorting, and pagination.
// Returns total_count via window function for pagination UI.
//
//	SELECT
//	    v.id, v.created_at, v.updated_at, v.src, v.archived_by, v.title, v.info, v.comments, v.video_path, v.thumbnail_path, v.description, v.tags, v.uploader, v.uploader_id, v.channel_id, v.upload_date, v.duration_seconds, v.view_count, v.like_count, v.thumb_gradient_start, v.thumb_gradient_end, v.thumb_gradient_angle, v.file_hash, v.file_size, v.assets_status, v.search, v.probe_data,
//	    COUNT(*) OVER() AS total_count,
//	    COALESCE((SELECT COUNT(*) FROM clips c WHERE c.video_id = v.id), 0) AS clip_count,
//	    COALESCE((SELECT COUNT(*) FROM markers m WHERE m.video_id = v.id), 0) AS marker_count,
//	    COALESCE((SELECT MAX(c.created_at) FROM clips c WHERE c.video_id = v.id), '1970-01-01'::timestamptz) AS last_clip_at,
//	    COALESCE((SELECT MAX(m.created_at) FROM markers m WHERE m.video_id = v.id), '1970-01-01'::timestamptz) AS last_marker_at,
//	    COALESCE(u.user_name, 'unknown') AS archived_by_username
//	FROM videos v
//	LEFT JOIN users u ON v.archived_by = u.id
//	WHERE
//	    -- Full-text search (optional)
//	    ($1::text IS NULL OR v.search @@ plainto_tsquery('simple', $1))
//	    -- Uploader filter (optional)
//	    AND ($2::text IS NULL OR v.uploader = $2)
//	    -- Channel filter (optional)
//	    AND ($3::text IS NULL OR v.channel_id = $3)
//	    -- Duration filter: short=<5min, medium=5-30min, long=>30min
//	    AND (
//	        $4::text IS NULL
//	        OR ($4 = 'short' AND v.duration_seconds < 300)
//	        OR ($4 = 'medium' AND v.duration_seconds >= 300 AND v.duration_seconds < 1800)
//	        OR ($4 = 'long' AND v.duration_seconds >= 1800)
//	    )
//	    -- Tags filter (any tag matches)
//	    AND ($5::text[] IS NULL OR v.tags && $5::text[])
//	    -- Date range (archived or published based on date_type)
//	    AND (
//	        $6::date IS NULL
//	        OR ($7::text = 'published' AND v.upload_date >= $6)
//	        OR ($7::text IS DISTINCT FROM 'published' AND v.created_at::date >= $6)
//	    )
//	    AND (
//	        $8::date IS NULL
//	        OR ($7::text = 'published' AND v.upload_date <= $8)
//	        OR ($7::text IS DISTINCT FROM 'published' AND v.created_at::date <= $8)
//	    )
//	    -- Has clips filter
//	    AND ($9::boolean IS NULL OR $9 = FALSE
//	         OR EXISTS (SELECT 1 FROM clips c WHERE c.video_id = v.id))
//	    -- Has markers filter
//	    AND ($10::boolean IS NULL OR $10 = FALSE
//	         OR EXISTS (SELECT 1 FROM markers m WHERE m.video_id = v.id))
//	ORDER BY
//	    -- Date sorts (archived)
//	    CASE WHEN $11 = 'newest' THEN v.created_at END DESC NULLS LAST,
//	    CASE WHEN $11 = 'oldest' THEN v.created_at END ASC NULLS LAST,
//	    -- Date sorts (published)
//	    CASE WHEN $11 = 'published-newest' THEN v.upload_date END DESC NULLS LAST,
//	    CASE WHEN $11 = 'published-oldest' THEN v.upload_date END ASC NULLS LAST,
//	    -- Title sorts
//	    CASE WHEN $11 = 'alpha' THEN v.title END ASC NULLS LAST,
//	    CASE WHEN $11 = 'alpha-desc' THEN v.title END DESC NULLS LAST,
//	    -- Duration sorts
//	    CASE WHEN $11 = 'duration' THEN v.duration_seconds END ASC NULLS LAST,
//	    CASE WHEN $11 = 'duration-desc' THEN v.duration_seconds END DESC NULLS LAST,
//	    -- Activity sorts
//	    CASE WHEN $11 = 'most-clips' THEN (SELECT COUNT(*) FROM clips c WHERE c.video_id = v.id) END DESC NULLS LAST,
//	    CASE WHEN $11 = 'most-markers' THEN (SELECT COUNT(*) FROM markers m WHERE m.video_id = v.id) END DESC NULLS LAST,
//	    CASE WHEN $11 = 'recently-clipped' THEN (SELECT MAX(c.created_at) FROM clips c WHERE c.video_id = v.id) END DESC NULLS LAST,
//	    CASE WHEN $11 = 'recently-marked' THEN (SELECT MAX(m.created_at) FROM markers m WHERE m.video_id = v.id) END DESC NULLS LAST,
//	    -- Default fallback
//	    v.created_at DESC
//	LIMIT $13
//	OFFSET $12
func (q *Queries) ListVideosPaginated(ctx context.Context, arg *ListVideosPaginatedParams) ([]*ListVideosPaginatedRow, error) {
	rows, err := q.db.Query(ctx, listVideosPaginated,
		arg.Query,
		arg.Uploader,
		arg.ChannelID,
		arg.DurationFilter,
		arg.Tags,
		arg.DateFrom,
		arg.DateType,
		arg.DateTo,
		arg.HasClips,
		arg.HasMarkers,
		arg.SortOrder,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListVideosPaginatedRow
	for rows.Next() {
		var i ListVideosPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Src,
			&i.ArchivedBy,
			&i.Title,
			&i.Info,
			&i.Comments,
			&i.VideoPath,
			&i.ThumbnailPath,
			&i.Description,
			&i.Tags,
			&i.Uploader,
			&i.UploaderID,
			&i.ChannelID,
			&i.UploadDate,
			&i.DurationSeconds,
			&i.ViewCount,
			&i.LikeCount,
			&i.ThumbGradientStart,
			&i.ThumbGradientEnd,
			&i.ThumbGradientAngle,
			&i.FileHash,
			&i.FileSize,
			&i.AssetsStatus,
			&i.Search,
			&i.ProbeData,
			&i.TotalCount,
			&i.ClipCount,
			&i.MarkerCount,
			&i.LastClipAt,
			&i.LastMarkerAt,
			&i.ArchivedByUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
