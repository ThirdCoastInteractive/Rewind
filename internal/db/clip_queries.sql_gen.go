// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: clip_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"thirdcoast.systems/rewind/pkg/utils/crops"
)

const clearClipExportPID = `-- name: ClearClipExportPID :exec
UPDATE clip_exports
SET pid = NULL,
    updated_at = NOW()
WHERE id = $1
`

// Clear the PID when process completes
//
//	UPDATE clip_exports
//	SET pid = NULL,
//	    updated_at = NOW()
//	WHERE id = $1
func (q *Queries) ClearClipExportPID(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, clearClipExportPID, id)
	return err
}

const countClipExports = `-- name: CountClipExports :one
SELECT COUNT(*) FROM clip_exports
`

// CountClipExports
//
//	SELECT COUNT(*) FROM clip_exports
func (q *Queries) CountClipExports(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countClipExports)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createClip = `-- name: CreateClip :one
INSERT INTO clips (
    video_id,
    start_ts,
    end_ts,
    duration,
    title,
    description,
    color,
    tags,
    created_by
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
) RETURNING id, video_id, start_ts, end_ts, duration, created_at, updated_at, created_by, title, description, color, tags, crops, filter_stack
`

type CreateClipParams struct {
	VideoID     pgtype.UUID `db:"video_id" json:"VideoID"`
	StartTs     float64     `db:"start_ts" json:"StartTs"`
	EndTs       float64     `db:"end_ts" json:"EndTs"`
	Duration    float64     `db:"duration" json:"Duration"`
	Title       string      `db:"title" json:"Title"`
	Description string      `db:"description" json:"Description"`
	Color       string      `db:"color" json:"Color"`
	Tags        []byte      `db:"tags" json:"Tags"`
	CreatedBy   pgtype.UUID `db:"created_by" json:"CreatedBy"`
}

// CreateClip
//
//	INSERT INTO clips (
//	    video_id,
//	    start_ts,
//	    end_ts,
//	    duration,
//	    title,
//	    description,
//	    color,
//	    tags,
//	    created_by
//	) VALUES (
//	    $1,
//	    $2,
//	    $3,
//	    $4,
//	    $5,
//	    $6,
//	    $7,
//	    $8,
//	    $9
//	) RETURNING id, video_id, start_ts, end_ts, duration, created_at, updated_at, created_by, title, description, color, tags, crops, filter_stack
func (q *Queries) CreateClip(ctx context.Context, arg *CreateClipParams) (*Clip, error) {
	row := q.db.QueryRow(ctx, createClip,
		arg.VideoID,
		arg.StartTs,
		arg.EndTs,
		arg.Duration,
		arg.Title,
		arg.Description,
		arg.Color,
		arg.Tags,
		arg.CreatedBy,
	)
	var i Clip
	err := row.Scan(
		&i.ID,
		&i.VideoID,
		&i.StartTs,
		&i.EndTs,
		&i.Duration,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.Title,
		&i.Description,
		&i.Color,
		&i.Tags,
		&i.Crops,
		&i.FilterStack,
	)
	return &i, err
}

const createClipExport = `-- name: CreateClipExport :one
INSERT INTO clip_exports (clip_id, created_by, format, variant, spec, clip_updated_at, file_path, status, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, '', 'queued', NOW(), NOW())
RETURNING id
`

type CreateClipExportParams struct {
	ClipID        pgtype.UUID        `db:"clip_id" json:"ClipID"`
	CreatedBy     pgtype.UUID        `db:"created_by" json:"CreatedBy"`
	Format        string             `db:"format" json:"Format"`
	Variant       string             `db:"variant" json:"Variant"`
	Spec          []byte             `db:"spec" json:"Spec"`
	ClipUpdatedAt pgtype.Timestamptz `db:"clip_updated_at" json:"ClipUpdatedAt"`
}

// CreateClipExport
//
//	INSERT INTO clip_exports (clip_id, created_by, format, variant, spec, clip_updated_at, file_path, status, created_at, updated_at)
//	VALUES ($1, $2, $3, $4, $5, $6, '', 'queued', NOW(), NOW())
//	RETURNING id
func (q *Queries) CreateClipExport(ctx context.Context, arg *CreateClipExportParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createClipExport,
		arg.ClipID,
		arg.CreatedBy,
		arg.Format,
		arg.Variant,
		arg.Spec,
		arg.ClipUpdatedAt,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteAllClipExports = `-- name: DeleteAllClipExports :exec
DELETE FROM clip_exports
`

// Delete all exports (files must be cleaned up separately)
//
//	DELETE FROM clip_exports
func (q *Queries) DeleteAllClipExports(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllClipExports)
	return err
}

const deleteClip = `-- name: DeleteClip :exec
DELETE FROM clips
WHERE id = $1
`

// DeleteClip
//
//	DELETE FROM clips
//	WHERE id = $1
func (q *Queries) DeleteClip(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteClip, id)
	return err
}

const deleteClipExport = `-- name: DeleteClipExport :exec
DELETE FROM clip_exports WHERE id = $1
`

// DeleteClipExport
//
//	DELETE FROM clip_exports WHERE id = $1
func (q *Queries) DeleteClipExport(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteClipExport, id)
	return err
}

const deleteClipExportsByStatus = `-- name: DeleteClipExportsByStatus :exec
DELETE FROM clip_exports WHERE status = $1
`

// Delete exports by status (files must be cleaned up separately)
//
//	DELETE FROM clip_exports WHERE status = $1
func (q *Queries) DeleteClipExportsByStatus(ctx context.Context, status ExportStatus) error {
	_, err := q.db.Exec(ctx, deleteClipExportsByStatus, status)
	return err
}

const deleteClipsByVideo = `-- name: DeleteClipsByVideo :exec
DELETE FROM clips
WHERE video_id = $1
`

// DeleteClipsByVideo
//
//	DELETE FROM clips
//	WHERE video_id = $1
func (q *Queries) DeleteClipsByVideo(ctx context.Context, videoID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteClipsByVideo, videoID)
	return err
}

const findAndLockPendingClipExport = `-- name: FindAndLockPendingClipExport :one

UPDATE clip_exports
SET status = 'processing',
    locked_at = NOW(),
    locked_by = $1,
    started_at = NOW(),
    attempts = attempts + 1,
    updated_at = NOW()
WHERE id = (
    SELECT id FROM clip_exports
    WHERE status = 'queued'
      AND (locked_at IS NULL OR locked_at < NOW() - INTERVAL '10 minutes')
    ORDER BY created_at ASC
    LIMIT 1
    FOR UPDATE SKIP LOCKED
)
RETURNING id, clip_id, created_by, format, variant, spec, clip_updated_at
`

type FindAndLockPendingClipExportRow struct {
	ID            pgtype.UUID        `db:"id" json:"ID"`
	ClipID        pgtype.UUID        `db:"clip_id" json:"ClipID"`
	CreatedBy     pgtype.UUID        `db:"created_by" json:"CreatedBy"`
	Format        string             `db:"format" json:"Format"`
	Variant       string             `db:"variant" json:"Variant"`
	Spec          []byte             `db:"spec" json:"Spec"`
	ClipUpdatedAt pgtype.Timestamptz `db:"clip_updated_at" json:"ClipUpdatedAt"`
}

// ============================================================================
// ENCODER WORKER QUERIES
// ============================================================================
// Atomically find the oldest queued export and lock it for processing.
// Uses FOR UPDATE SKIP LOCKED so concurrent workers never claim the same row.
//
//	UPDATE clip_exports
//	SET status = 'processing',
//	    locked_at = NOW(),
//	    locked_by = $1,
//	    started_at = NOW(),
//	    attempts = attempts + 1,
//	    updated_at = NOW()
//	WHERE id = (
//	    SELECT id FROM clip_exports
//	    WHERE status = 'queued'
//	      AND (locked_at IS NULL OR locked_at < NOW() - INTERVAL '10 minutes')
//	    ORDER BY created_at ASC
//	    LIMIT 1
//	    FOR UPDATE SKIP LOCKED
//	)
//	RETURNING id, clip_id, created_by, format, variant, spec, clip_updated_at
func (q *Queries) FindAndLockPendingClipExport(ctx context.Context, lockedBy *string) (*FindAndLockPendingClipExportRow, error) {
	row := q.db.QueryRow(ctx, findAndLockPendingClipExport, lockedBy)
	var i FindAndLockPendingClipExportRow
	err := row.Scan(
		&i.ID,
		&i.ClipID,
		&i.CreatedBy,
		&i.Format,
		&i.Variant,
		&i.Spec,
		&i.ClipUpdatedAt,
	)
	return &i, err
}

const findOrCreatePendingClipExport = `-- name: FindOrCreatePendingClipExport :one
SELECT id, status, progress_pct, file_path
FROM clip_exports
WHERE clip_id = $1
  AND created_by = $2
  AND format = $3
  AND variant = $4
  AND status IN ('queued', 'processing')
  AND updated_at > NOW() - INTERVAL '5 minutes'
ORDER BY created_at DESC
LIMIT 1
`

type FindOrCreatePendingClipExportParams struct {
	ClipID    pgtype.UUID `db:"clip_id" json:"ClipID"`
	CreatedBy pgtype.UUID `db:"created_by" json:"CreatedBy"`
	Format    string      `db:"format" json:"Format"`
	Variant   string      `db:"variant" json:"Variant"`
}

type FindOrCreatePendingClipExportRow struct {
	ID          pgtype.UUID  `db:"id" json:"ID"`
	Status      ExportStatus `db:"status" json:"Status"`
	ProgressPct int32        `db:"progress_pct" json:"ProgressPct"`
	FilePath    string       `db:"file_path" json:"FilePath"`
}

// Find existing queued/processing export that is NOT stuck (updated in last 5 minutes)
//
//	SELECT id, status, progress_pct, file_path
//	FROM clip_exports
//	WHERE clip_id = $1
//	  AND created_by = $2
//	  AND format = $3
//	  AND variant = $4
//	  AND status IN ('queued', 'processing')
//	  AND updated_at > NOW() - INTERVAL '5 minutes'
//	ORDER BY created_at DESC
//	LIMIT 1
func (q *Queries) FindOrCreatePendingClipExport(ctx context.Context, arg *FindOrCreatePendingClipExportParams) (*FindOrCreatePendingClipExportRow, error) {
	row := q.db.QueryRow(ctx, findOrCreatePendingClipExport,
		arg.ClipID,
		arg.CreatedBy,
		arg.Format,
		arg.Variant,
	)
	var i FindOrCreatePendingClipExportRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ProgressPct,
		&i.FilePath,
	)
	return &i, err
}

const findOrphanedExportsWithPID = `-- name: FindOrphanedExportsWithPID :many
SELECT id, pid, file_path
FROM clip_exports
WHERE status = 'processing'
  AND locked_by = $1
  AND pid IS NOT NULL
`

type FindOrphanedExportsWithPIDRow struct {
	ID       pgtype.UUID `db:"id" json:"ID"`
	Pid      *int32      `db:"pid" json:"Pid"`
	FilePath string      `db:"file_path" json:"FilePath"`
}

// Find processing exports with PIDs that belong to this worker (for cleanup on restart)
//
//	SELECT id, pid, file_path
//	FROM clip_exports
//	WHERE status = 'processing'
//	  AND locked_by = $1
//	  AND pid IS NOT NULL
func (q *Queries) FindOrphanedExportsWithPID(ctx context.Context, lockedBy *string) ([]*FindOrphanedExportsWithPIDRow, error) {
	rows, err := q.db.Query(ctx, findOrphanedExportsWithPID, lockedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindOrphanedExportsWithPIDRow
	for rows.Next() {
		var i FindOrphanedExportsWithPIDRow
		if err := rows.Scan(&i.ID, &i.Pid, &i.FilePath); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findReadyExportsWithMissingFiles = `-- name: FindReadyExportsWithMissingFiles :many
SELECT id, file_path, clip_id
FROM clip_exports
WHERE status = 'ready'
  AND file_path != ''
ORDER BY created_at DESC
LIMIT 500
`

type FindReadyExportsWithMissingFilesRow struct {
	ID       pgtype.UUID `db:"id" json:"ID"`
	FilePath string      `db:"file_path" json:"FilePath"`
	ClipID   pgtype.UUID `db:"clip_id" json:"ClipID"`
}

// Find ready exports to check for missing files (for cleanup/requeue on startup)
//
//	SELECT id, file_path, clip_id
//	FROM clip_exports
//	WHERE status = 'ready'
//	  AND file_path != ''
//	ORDER BY created_at DESC
//	LIMIT 500
func (q *Queries) FindReadyExportsWithMissingFiles(ctx context.Context) ([]*FindReadyExportsWithMissingFilesRow, error) {
	rows, err := q.db.Query(ctx, findReadyExportsWithMissingFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindReadyExportsWithMissingFilesRow
	for rows.Next() {
		var i FindReadyExportsWithMissingFilesRow
		if err := rows.Scan(&i.ID, &i.FilePath, &i.ClipID); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findReusableClipExport = `-- name: FindReusableClipExport :one
SELECT id, file_path 
FROM clip_exports
WHERE clip_exports.clip_id = $1
  AND clip_exports.created_by = $2
  AND clip_exports.format = $3
  AND clip_exports.variant = $4
  AND clip_exports.status = 'ready'
  AND clip_exports.clip_updated_at >= (SELECT clips.updated_at FROM clips WHERE clips.id = $1)
ORDER BY clip_exports.created_at DESC
LIMIT 1
`

type FindReusableClipExportParams struct {
	ClipID    pgtype.UUID `db:"clip_id" json:"ClipID"`
	CreatedBy pgtype.UUID `db:"created_by" json:"CreatedBy"`
	Format    string      `db:"format" json:"Format"`
	Variant   string      `db:"variant" json:"Variant"`
}

type FindReusableClipExportRow struct {
	ID       pgtype.UUID `db:"id" json:"ID"`
	FilePath string      `db:"file_path" json:"FilePath"`
}

// FindReusableClipExport
//
//	SELECT id, file_path
//	FROM clip_exports
//	WHERE clip_exports.clip_id = $1
//	  AND clip_exports.created_by = $2
//	  AND clip_exports.format = $3
//	  AND clip_exports.variant = $4
//	  AND clip_exports.status = 'ready'
//	  AND clip_exports.clip_updated_at >= (SELECT clips.updated_at FROM clips WHERE clips.id = $1)
//	ORDER BY clip_exports.created_at DESC
//	LIMIT 1
func (q *Queries) FindReusableClipExport(ctx context.Context, arg *FindReusableClipExportParams) (*FindReusableClipExportRow, error) {
	row := q.db.QueryRow(ctx, findReusableClipExport,
		arg.ClipID,
		arg.CreatedBy,
		arg.Format,
		arg.Variant,
	)
	var i FindReusableClipExportRow
	err := row.Scan(&i.ID, &i.FilePath)
	return &i, err
}

const finishClipExportError = `-- name: FinishClipExportError :exec
UPDATE clip_exports
SET status = 'error',
    last_error = $1,
    finished_at = NOW(),
    locked_at = NULL,
    locked_by = NULL,
    pid = NULL,
    updated_at = NOW()
WHERE id = $2
`

type FinishClipExportErrorParams struct {
	LastError *string     `db:"last_error" json:"LastError"`
	ID        pgtype.UUID `db:"id" json:"ID"`
}

// Mark export as failed with error message
//
//	UPDATE clip_exports
//	SET status = 'error',
//	    last_error = $1,
//	    finished_at = NOW(),
//	    locked_at = NULL,
//	    locked_by = NULL,
//	    pid = NULL,
//	    updated_at = NOW()
//	WHERE id = $2
func (q *Queries) FinishClipExportError(ctx context.Context, arg *FinishClipExportErrorParams) error {
	_, err := q.db.Exec(ctx, finishClipExportError, arg.LastError, arg.ID)
	return err
}

const finishClipExportReady = `-- name: FinishClipExportReady :exec
UPDATE clip_exports
SET status = 'ready',
    file_path = $1,
    size_bytes = $2,
    progress_pct = 100,
    finished_at = NOW(),
    locked_at = NULL,
    locked_by = NULL,
    pid = NULL,
    last_accessed_at = NOW(),
    updated_at = NOW()
WHERE id = $3
`

type FinishClipExportReadyParams struct {
	FilePath  string      `db:"file_path" json:"FilePath"`
	SizeBytes int64       `db:"size_bytes" json:"SizeBytes"`
	ID        pgtype.UUID `db:"id" json:"ID"`
}

// Mark export as ready with file info
//
//	UPDATE clip_exports
//	SET status = 'ready',
//	    file_path = $1,
//	    size_bytes = $2,
//	    progress_pct = 100,
//	    finished_at = NOW(),
//	    locked_at = NULL,
//	    locked_by = NULL,
//	    pid = NULL,
//	    last_accessed_at = NOW(),
//	    updated_at = NOW()
//	WHERE id = $3
func (q *Queries) FinishClipExportReady(ctx context.Context, arg *FinishClipExportReadyParams) error {
	_, err := q.db.Exec(ctx, finishClipExportReady, arg.FilePath, arg.SizeBytes, arg.ID)
	return err
}

const getClip = `-- name: GetClip :one
SELECT id, video_id, start_ts, end_ts, duration, created_at, updated_at, created_by, title, description, color, tags, crops, filter_stack FROM clips
WHERE id = $1
`

// GetClip
//
//	SELECT id, video_id, start_ts, end_ts, duration, created_at, updated_at, created_by, title, description, color, tags, crops, filter_stack FROM clips
//	WHERE id = $1
func (q *Queries) GetClip(ctx context.Context, id pgtype.UUID) (*Clip, error) {
	row := q.db.QueryRow(ctx, getClip, id)
	var i Clip
	err := row.Scan(
		&i.ID,
		&i.VideoID,
		&i.StartTs,
		&i.EndTs,
		&i.Duration,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.Title,
		&i.Description,
		&i.Color,
		&i.Tags,
		&i.Crops,
		&i.FilterStack,
	)
	return &i, err
}

const getClipExportByID = `-- name: GetClipExportByID :one
SELECT id, file_path, status, last_error
FROM clip_exports
WHERE id = $1
`

type GetClipExportByIDRow struct {
	ID        pgtype.UUID  `db:"id" json:"ID"`
	FilePath  string       `db:"file_path" json:"FilePath"`
	Status    ExportStatus `db:"status" json:"Status"`
	LastError *string      `db:"last_error" json:"LastError"`
}

// GetClipExportByID
//
//	SELECT id, file_path, status, last_error
//	FROM clip_exports
//	WHERE id = $1
func (q *Queries) GetClipExportByID(ctx context.Context, id pgtype.UUID) (*GetClipExportByIDRow, error) {
	row := q.db.QueryRow(ctx, getClipExportByID, id)
	var i GetClipExportByIDRow
	err := row.Scan(
		&i.ID,
		&i.FilePath,
		&i.Status,
		&i.LastError,
	)
	return &i, err
}

const getClipExportForDownload = `-- name: GetClipExportForDownload :one
SELECT ce.file_path, ce.format, ce.status, ce.clip_id, ce.variant,
       COALESCE(c.title, '') AS clip_title,
       c.crops
FROM clip_exports ce
JOIN clips c ON c.id = ce.clip_id
WHERE ce.id = $1
`

type GetClipExportForDownloadRow struct {
	FilePath  string          `db:"file_path" json:"FilePath"`
	Format    string          `db:"format" json:"Format"`
	Status    ExportStatus    `db:"status" json:"Status"`
	ClipID    pgtype.UUID     `db:"clip_id" json:"ClipID"`
	Variant   string          `db:"variant" json:"Variant"`
	ClipTitle string          `db:"clip_title" json:"ClipTitle"`
	Crops     crops.CropArray `db:"crops" json:"Crops"`
}

// GetClipExportForDownload
//
//	SELECT ce.file_path, ce.format, ce.status, ce.clip_id, ce.variant,
//	       COALESCE(c.title, '') AS clip_title,
//	       c.crops
//	FROM clip_exports ce
//	JOIN clips c ON c.id = ce.clip_id
//	WHERE ce.id = $1
func (q *Queries) GetClipExportForDownload(ctx context.Context, id pgtype.UUID) (*GetClipExportForDownloadRow, error) {
	row := q.db.QueryRow(ctx, getClipExportForDownload, id)
	var i GetClipExportForDownloadRow
	err := row.Scan(
		&i.FilePath,
		&i.Format,
		&i.Status,
		&i.ClipID,
		&i.Variant,
		&i.ClipTitle,
		&i.Crops,
	)
	return &i, err
}

const getClipExportStats = `-- name: GetClipExportStats :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'queued') AS queued_count,
    COUNT(*) FILTER (WHERE status = 'processing') AS processing_count,
    COUNT(*) FILTER (WHERE status = 'ready') AS ready_count,
    COUNT(*) FILTER (WHERE status = 'error') AS error_count,
    COALESCE(SUM(size_bytes) FILTER (WHERE status = 'ready'), 0)::bigint AS total_size_bytes
FROM clip_exports
`

type GetClipExportStatsRow struct {
	QueuedCount     int64 `db:"queued_count" json:"QueuedCount"`
	ProcessingCount int64 `db:"processing_count" json:"ProcessingCount"`
	ReadyCount      int64 `db:"ready_count" json:"ReadyCount"`
	ErrorCount      int64 `db:"error_count" json:"ErrorCount"`
	TotalSizeBytes  int64 `db:"total_size_bytes" json:"TotalSizeBytes"`
}

// Get export statistics for admin dashboard
//
//	SELECT
//	    COUNT(*) FILTER (WHERE status = 'queued') AS queued_count,
//	    COUNT(*) FILTER (WHERE status = 'processing') AS processing_count,
//	    COUNT(*) FILTER (WHERE status = 'ready') AS ready_count,
//	    COUNT(*) FILTER (WHERE status = 'error') AS error_count,
//	    COALESCE(SUM(size_bytes) FILTER (WHERE status = 'ready'), 0)::bigint AS total_size_bytes
//	FROM clip_exports
func (q *Queries) GetClipExportStats(ctx context.Context) (*GetClipExportStatsRow, error) {
	row := q.db.QueryRow(ctx, getClipExportStats)
	var i GetClipExportStatsRow
	err := row.Scan(
		&i.QueuedCount,
		&i.ProcessingCount,
		&i.ReadyCount,
		&i.ErrorCount,
		&i.TotalSizeBytes,
	)
	return &i, err
}

const getClipExportStatus = `-- name: GetClipExportStatus :one
SELECT id, clip_id, status, progress_pct, file_path, last_error
FROM clip_exports
WHERE id = $1
`

type GetClipExportStatusRow struct {
	ID          pgtype.UUID  `db:"id" json:"ID"`
	ClipID      pgtype.UUID  `db:"clip_id" json:"ClipID"`
	Status      ExportStatus `db:"status" json:"Status"`
	ProgressPct int32        `db:"progress_pct" json:"ProgressPct"`
	FilePath    string       `db:"file_path" json:"FilePath"`
	LastError   *string      `db:"last_error" json:"LastError"`
}

// Get current export status for SSE streaming
//
//	SELECT id, clip_id, status, progress_pct, file_path, last_error
//	FROM clip_exports
//	WHERE id = $1
func (q *Queries) GetClipExportStatus(ctx context.Context, id pgtype.UUID) (*GetClipExportStatusRow, error) {
	row := q.db.QueryRow(ctx, getClipExportStatus, id)
	var i GetClipExportStatusRow
	err := row.Scan(
		&i.ID,
		&i.ClipID,
		&i.Status,
		&i.ProgressPct,
		&i.FilePath,
		&i.LastError,
	)
	return &i, err
}

const getClipExportStorageLimit = `-- name: GetClipExportStorageLimit :one
SELECT COALESCE(clip_export_storage_limit_bytes, 0) FROM instance_settings WHERE id = 1
`

// GetClipExportStorageLimit
//
//	SELECT COALESCE(clip_export_storage_limit_bytes, 0) FROM instance_settings WHERE id = 1
func (q *Queries) GetClipExportStorageLimit(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getClipExportStorageLimit)
	var clip_export_storage_limit_bytes int64
	err := row.Scan(&clip_export_storage_limit_bytes)
	return clip_export_storage_limit_bytes, err
}

const getClipForExport = `-- name: GetClipForExport :one
SELECT c.id, c.video_id, c.start_ts, c.end_ts, c.duration, c.crops, c.filter_stack,
       c.title AS clip_title, v.video_path
FROM clips c
JOIN videos v ON v.id = c.video_id
WHERE c.id = $1
`

type GetClipForExportRow struct {
	ID          pgtype.UUID     `db:"id" json:"ID"`
	VideoID     pgtype.UUID     `db:"video_id" json:"VideoID"`
	StartTs     float64         `db:"start_ts" json:"StartTs"`
	EndTs       float64         `db:"end_ts" json:"EndTs"`
	Duration    float64         `db:"duration" json:"Duration"`
	Crops       crops.CropArray `db:"crops" json:"Crops"`
	FilterStack []byte          `db:"filter_stack" json:"FilterStack"`
	ClipTitle   string          `db:"clip_title" json:"ClipTitle"`
	VideoPath   *string         `db:"video_path" json:"VideoPath"`
}

// Get clip data needed for encoding
//
//	SELECT c.id, c.video_id, c.start_ts, c.end_ts, c.duration, c.crops, c.filter_stack,
//	       c.title AS clip_title, v.video_path
//	FROM clips c
//	JOIN videos v ON v.id = c.video_id
//	WHERE c.id = $1
func (q *Queries) GetClipForExport(ctx context.Context, id pgtype.UUID) (*GetClipForExportRow, error) {
	row := q.db.QueryRow(ctx, getClipForExport, id)
	var i GetClipForExportRow
	err := row.Scan(
		&i.ID,
		&i.VideoID,
		&i.StartTs,
		&i.EndTs,
		&i.Duration,
		&i.Crops,
		&i.FilterStack,
		&i.ClipTitle,
		&i.VideoPath,
	)
	return &i, err
}

const getTotalClipExportSize = `-- name: GetTotalClipExportSize :one
SELECT COALESCE(SUM(size_bytes), 0)::bigint FROM clip_exports WHERE status = 'ready'
`

// GetTotalClipExportSize
//
//	SELECT COALESCE(SUM(size_bytes), 0)::bigint FROM clip_exports WHERE status = 'ready'
func (q *Queries) GetTotalClipExportSize(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalClipExportSize)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const listActiveExportsForClips = `-- name: ListActiveExportsForClips :many
SELECT id, clip_id, status, progress_pct, file_path
FROM clip_exports
WHERE clip_id = ANY($1::uuid[])
  AND (
    (status IN ('queued', 'processing') AND updated_at > NOW() - INTERVAL '5 minutes')
    OR status = 'ready'
  )
ORDER BY clip_id, created_at DESC
`

type ListActiveExportsForClipsRow struct {
	ID          pgtype.UUID  `db:"id" json:"ID"`
	ClipID      pgtype.UUID  `db:"clip_id" json:"ClipID"`
	Status      ExportStatus `db:"status" json:"Status"`
	ProgressPct int32        `db:"progress_pct" json:"ProgressPct"`
	FilePath    string       `db:"file_path" json:"FilePath"`
}

// Get active exports for a list of clip IDs (for clip bank hydration)
// Only show processing/queued exports that are actively being worked on (updated in last 5 min)
//
//	SELECT id, clip_id, status, progress_pct, file_path
//	FROM clip_exports
//	WHERE clip_id = ANY($1::uuid[])
//	  AND (
//	    (status IN ('queued', 'processing') AND updated_at > NOW() - INTERVAL '5 minutes')
//	    OR status = 'ready'
//	  )
//	ORDER BY clip_id, created_at DESC
func (q *Queries) ListActiveExportsForClips(ctx context.Context, clipIds []pgtype.UUID) ([]*ListActiveExportsForClipsRow, error) {
	rows, err := q.db.Query(ctx, listActiveExportsForClips, clipIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListActiveExportsForClipsRow
	for rows.Next() {
		var i ListActiveExportsForClipsRow
		if err := rows.Scan(
			&i.ID,
			&i.ClipID,
			&i.Status,
			&i.ProgressPct,
			&i.FilePath,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClipExportFilesByStatus = `-- name: ListClipExportFilesByStatus :many
SELECT id, file_path FROM clip_exports 
WHERE status = $1 AND file_path != ''
`

type ListClipExportFilesByStatusRow struct {
	ID       pgtype.UUID `db:"id" json:"ID"`
	FilePath string      `db:"file_path" json:"FilePath"`
}

// Get file paths for exports by status (for cleanup before delete)
//
//	SELECT id, file_path FROM clip_exports
//	WHERE status = $1 AND file_path != ''
func (q *Queries) ListClipExportFilesByStatus(ctx context.Context, status ExportStatus) ([]*ListClipExportFilesByStatusRow, error) {
	rows, err := q.db.Query(ctx, listClipExportFilesByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListClipExportFilesByStatusRow
	for rows.Next() {
		var i ListClipExportFilesByStatusRow
		if err := rows.Scan(&i.ID, &i.FilePath); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClipExportsForAdmin = `-- name: ListClipExportsForAdmin :many
SELECT 
    ce.id,
    ce.clip_id,
    c.video_id,
    ce.status,
    ce.variant,
    ce.file_path,
    ce.size_bytes,
    ce.progress_pct,
    ce.attempts,
    ce.last_error,
    ce.created_at,
    ce.updated_at,
    c.title AS clip_label,
    c.duration AS clip_duration,
    v.title AS video_title
FROM clip_exports ce
JOIN clips c ON c.id = ce.clip_id
JOIN videos v ON v.id = c.video_id
ORDER BY ce.created_at DESC
LIMIT $2 OFFSET $1
`

type ListClipExportsForAdminParams struct {
	Off int32 `db:"off" json:"Off"`
	Lim int32 `db:"lim" json:"Lim"`
}

type ListClipExportsForAdminRow struct {
	ID           pgtype.UUID        `db:"id" json:"ID"`
	ClipID       pgtype.UUID        `db:"clip_id" json:"ClipID"`
	VideoID      pgtype.UUID        `db:"video_id" json:"VideoID"`
	Status       ExportStatus       `db:"status" json:"Status"`
	Variant      string             `db:"variant" json:"Variant"`
	FilePath     string             `db:"file_path" json:"FilePath"`
	SizeBytes    int64              `db:"size_bytes" json:"SizeBytes"`
	ProgressPct  int32              `db:"progress_pct" json:"ProgressPct"`
	Attempts     int32              `db:"attempts" json:"Attempts"`
	LastError    *string            `db:"last_error" json:"LastError"`
	CreatedAt    pgtype.Timestamptz `db:"created_at" json:"CreatedAt"`
	UpdatedAt    pgtype.Timestamptz `db:"updated_at" json:"UpdatedAt"`
	ClipLabel    string             `db:"clip_label" json:"ClipLabel"`
	ClipDuration float64            `db:"clip_duration" json:"ClipDuration"`
	VideoTitle   string             `db:"video_title" json:"VideoTitle"`
}

// List exports with clip/video info for admin management
//
//	SELECT
//	    ce.id,
//	    ce.clip_id,
//	    c.video_id,
//	    ce.status,
//	    ce.variant,
//	    ce.file_path,
//	    ce.size_bytes,
//	    ce.progress_pct,
//	    ce.attempts,
//	    ce.last_error,
//	    ce.created_at,
//	    ce.updated_at,
//	    c.title AS clip_label,
//	    c.duration AS clip_duration,
//	    v.title AS video_title
//	FROM clip_exports ce
//	JOIN clips c ON c.id = ce.clip_id
//	JOIN videos v ON v.id = c.video_id
//	ORDER BY ce.created_at DESC
//	LIMIT $2 OFFSET $1
func (q *Queries) ListClipExportsForAdmin(ctx context.Context, arg *ListClipExportsForAdminParams) ([]*ListClipExportsForAdminRow, error) {
	rows, err := q.db.Query(ctx, listClipExportsForAdmin, arg.Off, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListClipExportsForAdminRow
	for rows.Next() {
		var i ListClipExportsForAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.ClipID,
			&i.VideoID,
			&i.Status,
			&i.Variant,
			&i.FilePath,
			&i.SizeBytes,
			&i.ProgressPct,
			&i.Attempts,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClipLabel,
			&i.ClipDuration,
			&i.VideoTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClipsByVideo = `-- name: ListClipsByVideo :many
SELECT id, video_id, start_ts, end_ts, duration, created_at, updated_at, created_by, title, description, color, tags, crops, filter_stack FROM clips
WHERE video_id = $1
ORDER BY start_ts ASC
`

// ListClipsByVideo
//
//	SELECT id, video_id, start_ts, end_ts, duration, created_at, updated_at, created_by, title, description, color, tags, crops, filter_stack FROM clips
//	WHERE video_id = $1
//	ORDER BY start_ts ASC
func (q *Queries) ListClipsByVideo(ctx context.Context, videoID pgtype.UUID) ([]*Clip, error) {
	rows, err := q.db.Query(ctx, listClipsByVideo, videoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Clip
	for rows.Next() {
		var i Clip
		if err := rows.Scan(
			&i.ID,
			&i.VideoID,
			&i.StartTs,
			&i.EndTs,
			&i.Duration,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.Title,
			&i.Description,
			&i.Color,
			&i.Tags,
			&i.Crops,
			&i.FilterStack,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOldestClipExportsForCleanup = `-- name: ListOldestClipExportsForCleanup :many
SELECT id, file_path, size_bytes FROM clip_exports
WHERE status = 'ready'
ORDER BY last_accessed_at ASC NULLS FIRST
`

type ListOldestClipExportsForCleanupRow struct {
	ID        pgtype.UUID `db:"id" json:"ID"`
	FilePath  string      `db:"file_path" json:"FilePath"`
	SizeBytes int64       `db:"size_bytes" json:"SizeBytes"`
}

// ListOldestClipExportsForCleanup
//
//	SELECT id, file_path, size_bytes FROM clip_exports
//	WHERE status = 'ready'
//	ORDER BY last_accessed_at ASC NULLS FIRST
func (q *Queries) ListOldestClipExportsForCleanup(ctx context.Context) ([]*ListOldestClipExportsForCleanupRow, error) {
	rows, err := q.db.Query(ctx, listOldestClipExportsForCleanup)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListOldestClipExportsForCleanupRow
	for rows.Next() {
		var i ListOldestClipExportsForCleanupRow
		if err := rows.Scan(&i.ID, &i.FilePath, &i.SizeBytes); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const requeueAllErrorExports = `-- name: RequeueAllErrorExports :exec
UPDATE clip_exports
SET status = 'queued',
    locked_at = NULL,
    locked_by = NULL,
    pid = NULL,
    progress_pct = 0,
    attempts = 0,
    last_error = NULL,
    updated_at = NOW()
WHERE status = 'error'
`

// Requeue all failed exports
//
//	UPDATE clip_exports
//	SET status = 'queued',
//	    locked_at = NULL,
//	    locked_by = NULL,
//	    pid = NULL,
//	    progress_pct = 0,
//	    attempts = 0,
//	    last_error = NULL,
//	    updated_at = NOW()
//	WHERE status = 'error'
func (q *Queries) RequeueAllErrorExports(ctx context.Context) error {
	_, err := q.db.Exec(ctx, requeueAllErrorExports)
	return err
}

const requeueClipExport = `-- name: RequeueClipExport :exec
UPDATE clip_exports
SET status = 'queued',
    file_path = '',
    size_bytes = 0,
    locked_at = NULL,
    locked_by = NULL,
    progress_pct = 0,
    started_at = NULL,
    finished_at = NULL,
    last_error = 'Requeued: output file was missing',
    updated_at = NOW()
WHERE id = $1
`

// Re-queue an export that was marked ready but file is missing
//
//	UPDATE clip_exports
//	SET status = 'queued',
//	    file_path = '',
//	    size_bytes = 0,
//	    locked_at = NULL,
//	    locked_by = NULL,
//	    progress_pct = 0,
//	    started_at = NULL,
//	    finished_at = NULL,
//	    last_error = 'Requeued: output file was missing',
//	    updated_at = NOW()
//	WHERE id = $1
func (q *Queries) RequeueClipExport(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, requeueClipExport, id)
	return err
}

const resetStuckExports = `-- name: ResetStuckExports :exec
UPDATE clip_exports
SET status = 'queued',
    locked_at = NULL,
    locked_by = NULL,
    progress_pct = 0,
    updated_at = NOW()
WHERE status = 'processing'
  AND updated_at < NOW() - INTERVAL '5 minutes'
`

// Reset stuck exports that have been in processing state too long without updates
//
//	UPDATE clip_exports
//	SET status = 'queued',
//	    locked_at = NULL,
//	    locked_by = NULL,
//	    progress_pct = 0,
//	    updated_at = NOW()
//	WHERE status = 'processing'
//	  AND updated_at < NOW() - INTERVAL '5 minutes'
func (q *Queries) ResetStuckExports(ctx context.Context) error {
	_, err := q.db.Exec(ctx, resetStuckExports)
	return err
}

const unlockClipExport = `-- name: UnlockClipExport :exec
UPDATE clip_exports
SET locked_at = NULL,
    locked_by = NULL,
    pid = NULL,
    updated_at = NOW()
WHERE id = $1
`

// Release lock without changing status (for graceful shutdown)
//
//	UPDATE clip_exports
//	SET locked_at = NULL,
//	    locked_by = NULL,
//	    pid = NULL,
//	    updated_at = NOW()
//	WHERE id = $1
func (q *Queries) UnlockClipExport(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, unlockClipExport, id)
	return err
}

const updateClip = `-- name: UpdateClip :one
UPDATE clips
SET
    start_ts = COALESCE($1, start_ts),
    end_ts = COALESCE($2, end_ts),
    duration = COALESCE($3, duration),
    title = COALESCE($4, title),
    description = COALESCE($5, description),
    color = COALESCE($6, color),
    tags = COALESCE($7, tags),
    filter_stack = COALESCE($8, filter_stack),
    updated_at = NOW()
WHERE id = $9
RETURNING id, video_id, start_ts, end_ts, duration, created_at, updated_at, created_by, title, description, color, tags, crops, filter_stack
`

type UpdateClipParams struct {
	StartTs     *float64    `db:"start_ts" json:"StartTs"`
	EndTs       *float64    `db:"end_ts" json:"EndTs"`
	Duration    *float64    `db:"duration" json:"Duration"`
	Title       *string     `db:"title" json:"Title"`
	Description *string     `db:"description" json:"Description"`
	Color       *string     `db:"color" json:"Color"`
	Tags        []byte      `db:"tags" json:"Tags"`
	FilterStack []byte      `db:"filter_stack" json:"FilterStack"`
	ID          pgtype.UUID `db:"id" json:"ID"`
}

// UpdateClip
//
//	UPDATE clips
//	SET
//	    start_ts = COALESCE($1, start_ts),
//	    end_ts = COALESCE($2, end_ts),
//	    duration = COALESCE($3, duration),
//	    title = COALESCE($4, title),
//	    description = COALESCE($5, description),
//	    color = COALESCE($6, color),
//	    tags = COALESCE($7, tags),
//	    filter_stack = COALESCE($8, filter_stack),
//	    updated_at = NOW()
//	WHERE id = $9
//	RETURNING id, video_id, start_ts, end_ts, duration, created_at, updated_at, created_by, title, description, color, tags, crops, filter_stack
func (q *Queries) UpdateClip(ctx context.Context, arg *UpdateClipParams) (*Clip, error) {
	row := q.db.QueryRow(ctx, updateClip,
		arg.StartTs,
		arg.EndTs,
		arg.Duration,
		arg.Title,
		arg.Description,
		arg.Color,
		arg.Tags,
		arg.FilterStack,
		arg.ID,
	)
	var i Clip
	err := row.Scan(
		&i.ID,
		&i.VideoID,
		&i.StartTs,
		&i.EndTs,
		&i.Duration,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.Title,
		&i.Description,
		&i.Color,
		&i.Tags,
		&i.Crops,
		&i.FilterStack,
	)
	return &i, err
}

const updateClipCrops = `-- name: UpdateClipCrops :exec
UPDATE clips
SET crops = $1,
    updated_at = NOW()
WHERE id = $2
`

type UpdateClipCropsParams struct {
	Crops crops.CropArray `db:"crops" json:"Crops"`
	ID    pgtype.UUID     `db:"id" json:"ID"`
}

// UpdateClipCrops
//
//	UPDATE clips
//	SET crops = $1,
//	    updated_at = NOW()
//	WHERE id = $2
func (q *Queries) UpdateClipCrops(ctx context.Context, arg *UpdateClipCropsParams) error {
	_, err := q.db.Exec(ctx, updateClipCrops, arg.Crops, arg.ID)
	return err
}

const updateClipExportFilePath = `-- name: UpdateClipExportFilePath :exec
UPDATE clip_exports 
SET file_path = $1, updated_at = NOW() 
WHERE id = $2
`

type UpdateClipExportFilePathParams struct {
	FilePath string      `db:"file_path" json:"FilePath"`
	ID       pgtype.UUID `db:"id" json:"ID"`
}

// UpdateClipExportFilePath
//
//	UPDATE clip_exports
//	SET file_path = $1, updated_at = NOW()
//	WHERE id = $2
func (q *Queries) UpdateClipExportFilePath(ctx context.Context, arg *UpdateClipExportFilePathParams) error {
	_, err := q.db.Exec(ctx, updateClipExportFilePath, arg.FilePath, arg.ID)
	return err
}

const updateClipExportLastAccessed = `-- name: UpdateClipExportLastAccessed :exec
UPDATE clip_exports 
SET last_accessed_at = NOW(), updated_at = NOW() 
WHERE id = $1
`

// UpdateClipExportLastAccessed
//
//	UPDATE clip_exports
//	SET last_accessed_at = NOW(), updated_at = NOW()
//	WHERE id = $1
func (q *Queries) UpdateClipExportLastAccessed(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateClipExportLastAccessed, id)
	return err
}

const updateClipExportPID = `-- name: UpdateClipExportPID :exec
UPDATE clip_exports
SET pid = $1,
    updated_at = NOW()
WHERE id = $2
`

type UpdateClipExportPIDParams struct {
	Pid *int32      `db:"pid" json:"Pid"`
	ID  pgtype.UUID `db:"id" json:"ID"`
}

// Store the ffmpeg process PID for potential cleanup
//
//	UPDATE clip_exports
//	SET pid = $1,
//	    updated_at = NOW()
//	WHERE id = $2
func (q *Queries) UpdateClipExportPID(ctx context.Context, arg *UpdateClipExportPIDParams) error {
	_, err := q.db.Exec(ctx, updateClipExportPID, arg.Pid, arg.ID)
	return err
}

const updateClipExportProgress = `-- name: UpdateClipExportProgress :exec
UPDATE clip_exports
SET progress_pct = $1,
    updated_at = NOW()
WHERE id = $2
`

type UpdateClipExportProgressParams struct {
	ProgressPct int32       `db:"progress_pct" json:"ProgressPct"`
	ID          pgtype.UUID `db:"id" json:"ID"`
}

// Update progress percentage during encoding
//
//	UPDATE clip_exports
//	SET progress_pct = $1,
//	    updated_at = NOW()
//	WHERE id = $2
func (q *Queries) UpdateClipExportProgress(ctx context.Context, arg *UpdateClipExportProgressParams) error {
	_, err := q.db.Exec(ctx, updateClipExportProgress, arg.ProgressPct, arg.ID)
	return err
}

const updateClipFilterStack = `-- name: UpdateClipFilterStack :exec
UPDATE clips
SET filter_stack = $1,
    updated_at = NOW()
WHERE id = $2
`

type UpdateClipFilterStackParams struct {
	FilterStack []byte      `db:"filter_stack" json:"FilterStack"`
	ID          pgtype.UUID `db:"id" json:"ID"`
}

// UpdateClipFilterStack
//
//	UPDATE clips
//	SET filter_stack = $1,
//	    updated_at = NOW()
//	WHERE id = $2
func (q *Queries) UpdateClipFilterStack(ctx context.Context, arg *UpdateClipFilterStackParams) error {
	_, err := q.db.Exec(ctx, updateClipFilterStack, arg.FilterStack, arg.ID)
	return err
}
