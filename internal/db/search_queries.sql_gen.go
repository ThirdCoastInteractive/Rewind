// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: search_queries.sql

package db

import (
	"context"
)

const searchVideos = `-- name: SearchVideos :many
WITH q AS (
  SELECT plainto_tsquery('simple', $3) AS tsq
),
video_hits AS (
  SELECT v.id AS video_id, ts_rank_cd(v.search, q.tsq) AS rank
  FROM videos v, q
  WHERE v.search @@ q.tsq
),
comment_hits AS (
  SELECT vc.video_id AS video_id, max(ts_rank_cd(vc.search, q.tsq)) AS rank
  FROM video_comments vc, q
  JOIN videos v ON v.id = vc.video_id
  WHERE vc.search @@ q.tsq
  GROUP BY vc.video_id
),
transcript_hits AS (
  SELECT vt.video_id AS video_id, max(ts_rank_cd(vt.search, q.tsq)) AS rank
  FROM video_transcripts vt, q
  JOIN videos v ON v.id = vt.video_id
  WHERE vt.search @@ q.tsq
  GROUP BY vt.video_id
),
hits AS (
  SELECT video_id, rank FROM video_hits
  UNION ALL
  SELECT video_id, rank FROM comment_hits
  UNION ALL
  SELECT video_id, rank FROM transcript_hits
),
ranked AS (
  SELECT video_id, sum(rank) AS rank
  FROM hits
  GROUP BY video_id
)
SELECT v.id, v.created_at, v.updated_at, v.src, v.archived_by, v.title, v.info, v.comments, v.video_path, v.thumbnail_path, v.description, v.tags, v.uploader, v.uploader_id, v.channel_id, v.upload_date, v.duration_seconds, v.view_count, v.like_count, v.thumb_gradient_start, v.thumb_gradient_end, v.thumb_gradient_angle, v.file_hash, v.file_size, v.assets_status, v.search, v.probe_data
FROM ranked r
JOIN videos v ON v.id = r.video_id
ORDER BY r.rank DESC, v.created_at DESC
LIMIT $2
OFFSET $1
`

type SearchVideosParams struct {
	PageOffset int32  `db:"page_offset" json:"PageOffset"`
	PageLimit  int32  `db:"page_limit" json:"PageLimit"`
	Query      string `db:"query" json:"Query"`
}

// SearchVideos searches title/description/tags + comments + transcript.
//
//	WITH q AS (
//	  SELECT plainto_tsquery('simple', $3) AS tsq
//	),
//	video_hits AS (
//	  SELECT v.id AS video_id, ts_rank_cd(v.search, q.tsq) AS rank
//	  FROM videos v, q
//	  WHERE v.search @@ q.tsq
//	),
//	comment_hits AS (
//	  SELECT vc.video_id AS video_id, max(ts_rank_cd(vc.search, q.tsq)) AS rank
//	  FROM video_comments vc, q
//	  JOIN videos v ON v.id = vc.video_id
//	  WHERE vc.search @@ q.tsq
//	  GROUP BY vc.video_id
//	),
//	transcript_hits AS (
//	  SELECT vt.video_id AS video_id, max(ts_rank_cd(vt.search, q.tsq)) AS rank
//	  FROM video_transcripts vt, q
//	  JOIN videos v ON v.id = vt.video_id
//	  WHERE vt.search @@ q.tsq
//	  GROUP BY vt.video_id
//	),
//	hits AS (
//	  SELECT video_id, rank FROM video_hits
//	  UNION ALL
//	  SELECT video_id, rank FROM comment_hits
//	  UNION ALL
//	  SELECT video_id, rank FROM transcript_hits
//	),
//	ranked AS (
//	  SELECT video_id, sum(rank) AS rank
//	  FROM hits
//	  GROUP BY video_id
//	)
//	SELECT v.id, v.created_at, v.updated_at, v.src, v.archived_by, v.title, v.info, v.comments, v.video_path, v.thumbnail_path, v.description, v.tags, v.uploader, v.uploader_id, v.channel_id, v.upload_date, v.duration_seconds, v.view_count, v.like_count, v.thumb_gradient_start, v.thumb_gradient_end, v.thumb_gradient_angle, v.file_hash, v.file_size, v.assets_status, v.search, v.probe_data
//	FROM ranked r
//	JOIN videos v ON v.id = r.video_id
//	ORDER BY r.rank DESC, v.created_at DESC
//	LIMIT $2
//	OFFSET $1
func (q *Queries) SearchVideos(ctx context.Context, arg *SearchVideosParams) ([]*Video, error) {
	rows, err := q.db.Query(ctx, searchVideos, arg.PageOffset, arg.PageLimit, arg.Query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Video
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Src,
			&i.ArchivedBy,
			&i.Title,
			&i.Info,
			&i.Comments,
			&i.VideoPath,
			&i.ThumbnailPath,
			&i.Description,
			&i.Tags,
			&i.Uploader,
			&i.UploaderID,
			&i.ChannelID,
			&i.UploadDate,
			&i.DurationSeconds,
			&i.ViewCount,
			&i.LikeCount,
			&i.ThumbGradientStart,
			&i.ThumbGradientEnd,
			&i.ThumbGradientAngle,
			&i.FileHash,
			&i.FileSize,
			&i.AssetsStatus,
			&i.Search,
			&i.ProbeData,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
