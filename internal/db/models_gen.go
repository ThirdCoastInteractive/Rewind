// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
	"thirdcoast.systems/rewind/pkg/utils/crops"
	"thirdcoast.systems/rewind/pkg/utils/crypto"
	"thirdcoast.systems/rewind/pkg/utils/language"
	"thirdcoast.systems/rewind/pkg/utils/passwords"
	"thirdcoast.systems/rewind/pkg/videoinfo"
)

type ExportStatus string

const (
	ExportStatusQueued     ExportStatus = "queued"
	ExportStatusProcessing ExportStatus = "processing"
	ExportStatusReady      ExportStatus = "ready"
	ExportStatusError      ExportStatus = "error"
)

func (e *ExportStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ExportStatus(s)
	case string:
		*e = ExportStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ExportStatus: %T", src)
	}
	return nil
}

type NullExportStatus struct {
	ExportStatus ExportStatus `json:"ExportStatus"`
	Valid        bool         `json:"Valid"` // Valid is true if ExportStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullExportStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ExportStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ExportStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullExportStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ExportStatus), nil
}

func (e ExportStatus) Valid() bool {
	switch e {
	case ExportStatusQueued,
		ExportStatusProcessing,
		ExportStatusReady,
		ExportStatusError:
		return true
	}
	return false
}

func AllExportStatusValues() []ExportStatus {
	return []ExportStatus{
		ExportStatusQueued,
		ExportStatusProcessing,
		ExportStatusReady,
		ExportStatusError,
	}
}

type JobStatus string

const (
	JobStatusQueued     JobStatus = "queued"
	JobStatusProcessing JobStatus = "processing"
	JobStatusSucceeded  JobStatus = "succeeded"
	JobStatusFailed     JobStatus = "failed"
)

func (e *JobStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = JobStatus(s)
	case string:
		*e = JobStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for JobStatus: %T", src)
	}
	return nil
}

type NullJobStatus struct {
	JobStatus JobStatus `json:"JobStatus"`
	Valid     bool      `json:"Valid"` // Valid is true if JobStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullJobStatus) Scan(value interface{}) error {
	if value == nil {
		ns.JobStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.JobStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullJobStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.JobStatus), nil
}

func (e JobStatus) Valid() bool {
	switch e {
	case JobStatusQueued,
		JobStatusProcessing,
		JobStatusSucceeded,
		JobStatusFailed:
		return true
	}
	return false
}

func AllJobStatusValues() []JobStatus {
	return []JobStatus{
		JobStatusQueued,
		JobStatusProcessing,
		JobStatusSucceeded,
		JobStatusFailed,
	}
}

type LogStream string

const (
	LogStreamStdout LogStream = "stdout"
	LogStreamStderr LogStream = "stderr"
)

func (e *LogStream) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LogStream(s)
	case string:
		*e = LogStream(s)
	default:
		return fmt.Errorf("unsupported scan type for LogStream: %T", src)
	}
	return nil
}

type NullLogStream struct {
	LogStream LogStream `json:"LogStream"`
	Valid     bool      `json:"Valid"` // Valid is true if LogStream is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLogStream) Scan(value interface{}) error {
	if value == nil {
		ns.LogStream, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LogStream.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLogStream) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LogStream), nil
}

func (e LogStream) Valid() bool {
	switch e {
	case LogStreamStdout,
		LogStreamStderr:
		return true
	}
	return false
}

func AllLogStreamValues() []LogStream {
	return []LogStream{
		LogStreamStdout,
		LogStreamStderr,
	}
}

type MarkerType string

const (
	MarkerTypePoint   MarkerType = "point"
	MarkerTypeChapter MarkerType = "chapter"
)

func (e *MarkerType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MarkerType(s)
	case string:
		*e = MarkerType(s)
	default:
		return fmt.Errorf("unsupported scan type for MarkerType: %T", src)
	}
	return nil
}

type NullMarkerType struct {
	MarkerType MarkerType `json:"MarkerType"`
	Valid      bool       `json:"Valid"` // Valid is true if MarkerType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMarkerType) Scan(value interface{}) error {
	if value == nil {
		ns.MarkerType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MarkerType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMarkerType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MarkerType), nil
}

func (e MarkerType) Valid() bool {
	switch e {
	case MarkerTypePoint,
		MarkerTypeChapter:
		return true
	}
	return false
}

func AllMarkerTypeValues() []MarkerType {
	return []MarkerType{
		MarkerTypePoint,
		MarkerTypeChapter,
	}
}

type UserRole string

const (
	UserRoleUser  UserRole = "user"
	UserRoleAdmin UserRole = "admin"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole `json:"UserRole"`
	Valid    bool     `json:"Valid"` // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

func (e UserRole) Valid() bool {
	switch e {
	case UserRoleUser,
		UserRoleAdmin:
		return true
	}
	return false
}

func AllUserRoleValues() []UserRole {
	return []UserRole{
		UserRoleUser,
		UserRoleAdmin,
	}
}

type Clip struct {
	ID          pgtype.UUID        `db:"id" json:"ID"`
	VideoID     pgtype.UUID        `db:"video_id" json:"VideoID"`
	StartTs     float64            `db:"start_ts" json:"StartTs"`
	EndTs       float64            `db:"end_ts" json:"EndTs"`
	Duration    float64            `db:"duration" json:"Duration"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"CreatedAt"`
	UpdatedAt   pgtype.Timestamptz `db:"updated_at" json:"UpdatedAt"`
	CreatedBy   pgtype.UUID        `db:"created_by" json:"CreatedBy"`
	Title       string             `db:"title" json:"Title"`
	Description string             `db:"description" json:"Description"`
	Color       string             `db:"color" json:"Color"`
	Tags        []byte             `db:"tags" json:"Tags"`
	Crops       crops.CropArray    `db:"crops" json:"Crops"`
	FilterStack []byte             `db:"filter_stack" json:"FilterStack"`
}

type ClipExport struct {
	ID             pgtype.UUID        `db:"id" json:"ID"`
	ClipID         pgtype.UUID        `db:"clip_id" json:"ClipID"`
	CreatedBy      pgtype.UUID        `db:"created_by" json:"CreatedBy"`
	Format         string             `db:"format" json:"Format"`
	FilePath       string             `db:"file_path" json:"FilePath"`
	SizeBytes      int64              `db:"size_bytes" json:"SizeBytes"`
	Status         ExportStatus       `db:"status" json:"Status"`
	LastError      *string            `db:"last_error" json:"LastError"`
	Variant        string             `db:"variant" json:"Variant"`
	ClipUpdatedAt  pgtype.Timestamptz `db:"clip_updated_at" json:"ClipUpdatedAt"`
	CreatedAt      pgtype.Timestamptz `db:"created_at" json:"CreatedAt"`
	UpdatedAt      pgtype.Timestamptz `db:"updated_at" json:"UpdatedAt"`
	LastAccessedAt pgtype.Timestamptz `db:"last_accessed_at" json:"LastAccessedAt"`
	Attempts       int32              `db:"attempts" json:"Attempts"`
	LockedAt       pgtype.Timestamptz `db:"locked_at" json:"LockedAt"`
	LockedBy       *string            `db:"locked_by" json:"LockedBy"`
	StartedAt      pgtype.Timestamptz `db:"started_at" json:"StartedAt"`
	FinishedAt     pgtype.Timestamptz `db:"finished_at" json:"FinishedAt"`
	ProgressPct    int32              `db:"progress_pct" json:"ProgressPct"`
	Pid            *int32             `db:"pid" json:"Pid"`
	Spec           []byte             `db:"spec" json:"Spec"`
}

type Cookie struct {
	ID         pgtype.UUID            `db:"id" json:"ID"`
	UserID     pgtype.UUID            `db:"user_id" json:"UserID"`
	Domain     string                 `db:"domain" json:"Domain"`
	Flag       string                 `db:"flag" json:"Flag"`
	Path       string                 `db:"path" json:"Path"`
	Secure     string                 `db:"secure" json:"Secure"`
	Expiration int64                  `db:"expiration" json:"Expiration"`
	Name       string                 `db:"name" json:"Name"`
	Value      crypto.EncryptedString `db:"value" json:"Value"`
	CreatedAt  pgtype.Timestamptz     `db:"created_at" json:"CreatedAt"`
	UpdatedAt  pgtype.Timestamptz     `db:"updated_at" json:"UpdatedAt"`
}

type DownloadJob struct {
	ID           pgtype.UUID        `db:"id" json:"ID"`
	CreatedAt    pgtype.Timestamptz `db:"created_at" json:"CreatedAt"`
	UpdatedAt    pgtype.Timestamptz `db:"updated_at" json:"UpdatedAt"`
	URL          string             `db:"url" json:"Url"`
	ArchivedBy   pgtype.UUID        `db:"archived_by" json:"ArchivedBy"`
	Status       JobStatus          `db:"status" json:"Status"`
	Attempts     int32              `db:"attempts" json:"Attempts"`
	LastError    *string            `db:"last_error" json:"LastError"`
	StartedAt    pgtype.Timestamptz `db:"started_at" json:"StartedAt"`
	FinishedAt   pgtype.Timestamptz `db:"finished_at" json:"FinishedAt"`
	SpoolDir     *string            `db:"spool_dir" json:"SpoolDir"`
	InfoJsonPath *string            `db:"info_json_path" json:"InfoJsonPath"`
	VideoID      pgtype.UUID        `db:"video_id" json:"VideoID"`
	Refresh      bool               `db:"refresh" json:"Refresh"`
	ProcessPid   *int64             `db:"process_pid" json:"ProcessPid"`
	Archived     bool               `db:"archived" json:"Archived"`
	ExtraArgs    []string           `db:"extra_args" json:"ExtraArgs"`
}

type ExtensionToken struct {
	ID         pgtype.UUID        `db:"id" json:"ID"`
	UserID     pgtype.UUID        `db:"user_id" json:"UserID"`
	Token      string             `db:"token" json:"Token"`
	CreatedAt  pgtype.Timestamptz `db:"created_at" json:"CreatedAt"`
	LastUsedAt pgtype.Timestamptz `db:"last_used_at" json:"LastUsedAt"`
	ExpiresAt  pgtype.Timestamptz `db:"expires_at" json:"ExpiresAt"`
	Revoked    bool               `db:"revoked" json:"Revoked"`
}

type IngestJob struct {
	ID            pgtype.UUID        `db:"id" json:"ID"`
	CreatedAt     pgtype.Timestamptz `db:"created_at" json:"CreatedAt"`
	UpdatedAt     pgtype.Timestamptz `db:"updated_at" json:"UpdatedAt"`
	DownloadJobID pgtype.UUID        `db:"download_job_id" json:"DownloadJobID"`
	Status        JobStatus          `db:"status" json:"Status"`
	Attempts      int32              `db:"attempts" json:"Attempts"`
	LastError     *string            `db:"last_error" json:"LastError"`
	StartedAt     pgtype.Timestamptz `db:"started_at" json:"StartedAt"`
	FinishedAt    pgtype.Timestamptz `db:"finished_at" json:"FinishedAt"`
	AssetScope    *string            `db:"asset_scope" json:"AssetScope"`
}

type InstanceSetting struct {
	ID                          int32              `db:"id" json:"ID"`
	RegistrationEnabled         bool               `db:"registration_enabled" json:"RegistrationEnabled"`
	ClipExportStorageLimitBytes int64              `db:"clip_export_storage_limit_bytes" json:"ClipExportStorageLimitBytes"`
	AdminEmails                 []string           `db:"admin_emails" json:"AdminEmails"`
	UpdatedAt                   pgtype.Timestamptz `db:"updated_at" json:"UpdatedAt"`
}

type Marker struct {
	ID          pgtype.UUID        `db:"id" json:"ID"`
	VideoID     pgtype.UUID        `db:"video_id" json:"VideoID"`
	Timestamp   float64            `db:"timestamp" json:"Timestamp"`
	Title       string             `db:"title" json:"Title"`
	Description string             `db:"description" json:"Description"`
	Color       string             `db:"color" json:"Color"`
	MarkerType  MarkerType         `db:"marker_type" json:"MarkerType"`
	Duration    *float64           `db:"duration" json:"Duration"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"CreatedAt"`
	CreatedBy   pgtype.UUID        `db:"created_by" json:"CreatedBy"`
}

type PlaybackPosition struct {
	UserID          pgtype.UUID        `db:"user_id" json:"UserID"`
	VideoID         pgtype.UUID        `db:"video_id" json:"VideoID"`
	PositionSeconds float64            `db:"position_seconds" json:"PositionSeconds"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"UpdatedAt"`
}

type PlayerScenePreset struct {
	ID         pgtype.UUID        `db:"id" json:"ID"`
	ProducerID pgtype.UUID        `db:"producer_id" json:"ProducerID"`
	Name       string             `db:"name" json:"Name"`
	Scene      []byte             `db:"scene" json:"Scene"`
	CreatedAt  pgtype.Timestamptz `db:"created_at" json:"CreatedAt"`
	UpdatedAt  pgtype.Timestamptz `db:"updated_at" json:"UpdatedAt"`
}

type PlayerSession struct {
	ID             pgtype.UUID        `db:"id" json:"ID"`
	SessionCode    string             `db:"session_code" json:"SessionCode"`
	ProducerID     pgtype.UUID        `db:"producer_id" json:"ProducerID"`
	CurrentVideoID pgtype.UUID        `db:"current_video_id" json:"CurrentVideoID"`
	State          []byte             `db:"state" json:"State"`
	CreatedAt      pgtype.Timestamptz `db:"created_at" json:"CreatedAt"`
	ExpiresAt      pgtype.Timestamptz `db:"expires_at" json:"ExpiresAt"`
	LastActivity   pgtype.Timestamptz `db:"last_activity" json:"LastActivity"`
}

type User struct {
	ID                    pgtype.UUID        `db:"id" json:"ID"`
	UserName              string             `db:"user_name" json:"UserName"`
	Password              passwords.Password `db:"password" json:"Password"`
	Email                 string             `db:"email" json:"Email"`
	EmailVerified         bool               `db:"email_verified" json:"EmailVerified"`
	VerifyHash            *string            `db:"verify_hash" json:"VerifyHash"`
	Enabled               bool               `db:"enabled" json:"Enabled"`
	Role                  UserRole           `db:"role" json:"Role"`
	CreatedAt             pgtype.Timestamptz `db:"created_at" json:"CreatedAt"`
	UpdatedAt             pgtype.Timestamptz `db:"updated_at" json:"UpdatedAt"`
	DeletedAt             pgtype.Timestamptz `db:"deleted_at" json:"DeletedAt"`
	SessionsInvalidatedAt pgtype.Timestamptz `db:"sessions_invalidated_at" json:"SessionsInvalidatedAt"`
}

type UserKeybinding struct {
	UserID pgtype.UUID `db:"user_id" json:"UserID"`
	Action string      `db:"action" json:"Action"`
	Key    string      `db:"key" json:"Key"`
}

type Video struct {
	ID                 pgtype.UUID          `db:"id" json:"ID"`
	CreatedAt          pgtype.Timestamptz   `db:"created_at" json:"CreatedAt"`
	UpdatedAt          pgtype.Timestamptz   `db:"updated_at" json:"UpdatedAt"`
	Src                string               `db:"src" json:"Src"`
	ArchivedBy         pgtype.UUID          `db:"archived_by" json:"ArchivedBy"`
	Title              string               `db:"title" json:"Title"`
	Info               videoinfo.VideoInfo  `db:"info" json:"Info"`
	Comments           []byte               `db:"comments" json:"Comments"`
	VideoPath          *string              `db:"video_path" json:"VideoPath"`
	ThumbnailPath      *string              `db:"thumbnail_path" json:"ThumbnailPath"`
	Description        string               `db:"description" json:"Description"`
	Tags               []string             `db:"tags" json:"Tags"`
	Uploader           string               `db:"uploader" json:"Uploader"`
	UploaderID         *string              `db:"uploader_id" json:"UploaderID"`
	ChannelID          *string              `db:"channel_id" json:"ChannelID"`
	UploadDate         pgtype.Date          `db:"upload_date" json:"UploadDate"`
	DurationSeconds    *int32               `db:"duration_seconds" json:"DurationSeconds"`
	ViewCount          *int64               `db:"view_count" json:"ViewCount"`
	LikeCount          *int64               `db:"like_count" json:"LikeCount"`
	ThumbGradientStart *string              `db:"thumb_gradient_start" json:"ThumbGradientStart"`
	ThumbGradientEnd   *string              `db:"thumb_gradient_end" json:"ThumbGradientEnd"`
	ThumbGradientAngle *int32               `db:"thumb_gradient_angle" json:"ThumbGradientAngle"`
	FileHash           *string              `db:"file_hash" json:"FileHash"`
	FileSize           *int64               `db:"file_size" json:"FileSize"`
	AssetsStatus       AssetMap             `db:"assets_status" json:"AssetsStatus"`
	Search             string               `db:"search" json:"Search"`
	ProbeData          *videoinfo.ProbeInfo `db:"probe_data" json:"ProbeData"`
}

type VideoComment struct {
	ID          pgtype.UUID        `db:"id" json:"ID"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"CreatedAt"`
	UpdatedAt   pgtype.Timestamptz `db:"updated_at" json:"UpdatedAt"`
	VideoID     pgtype.UUID        `db:"video_id" json:"VideoID"`
	Source      string             `db:"source" json:"Source"`
	CommentID   string             `db:"comment_id" json:"CommentID"`
	ParentID    *string            `db:"parent_id" json:"ParentID"`
	Author      *string            `db:"author" json:"Author"`
	AuthorID    *string            `db:"author_id" json:"AuthorID"`
	AuthorURL   *string            `db:"author_url" json:"AuthorUrl"`
	PublishedAt pgtype.Timestamptz `db:"published_at" json:"PublishedAt"`
	LikeCount   *int64             `db:"like_count" json:"LikeCount"`
	Text        *string            `db:"text" json:"Text"`
	Raw         []byte             `db:"raw" json:"Raw"`
	Search      string             `db:"search" json:"Search"`
}

type VideoRevision struct {
	ID             pgtype.UUID        `db:"id" json:"ID"`
	VideoID        pgtype.UUID        `db:"video_id" json:"VideoID"`
	CreatedAt      pgtype.Timestamptz `db:"created_at" json:"CreatedAt"`
	Kind           string             `db:"kind" json:"Kind"`
	Diff           []byte             `db:"diff" json:"Diff"`
	OldTitle       *string            `db:"old_title" json:"OldTitle"`
	NewTitle       *string            `db:"new_title" json:"NewTitle"`
	OldDescription *string            `db:"old_description" json:"OldDescription"`
	NewDescription *string            `db:"new_description" json:"NewDescription"`
	OldInfo        []byte             `db:"old_info" json:"OldInfo"`
	NewInfo        []byte             `db:"new_info" json:"NewInfo"`
}

type VideoTranscript struct {
	ID        pgtype.UUID        `db:"id" json:"ID"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"CreatedAt"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"UpdatedAt"`
	VideoID   pgtype.UUID        `db:"video_id" json:"VideoID"`
	Lang      language.Tag       `db:"lang" json:"Lang"`
	Format    string             `db:"format" json:"Format"`
	Text      string             `db:"text" json:"Text"`
	Raw       string             `db:"raw" json:"Raw"`
	Search    string             `db:"search" json:"Search"`
}

type YtdlpLog struct {
	ID        int64              `db:"id" json:"ID"`
	JobID     pgtype.UUID        `db:"job_id" json:"JobID"`
	Stream    LogStream          `db:"stream" json:"Stream"`
	Message   string             `db:"message" json:"Message"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"CreatedAt"`
}
