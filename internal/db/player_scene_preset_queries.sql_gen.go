// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: player_scene_preset_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deletePlayerScenePreset = `-- name: DeletePlayerScenePreset :exec
DELETE FROM player_scene_presets
WHERE id = $1 AND producer_id = $2
`

type DeletePlayerScenePresetParams struct {
	ID         pgtype.UUID `db:"id" json:"ID"`
	ProducerID pgtype.UUID `db:"producer_id" json:"ProducerID"`
}

// DeletePlayerScenePreset
//
//	DELETE FROM player_scene_presets
//	WHERE id = $1 AND producer_id = $2
func (q *Queries) DeletePlayerScenePreset(ctx context.Context, arg *DeletePlayerScenePresetParams) error {
	_, err := q.db.Exec(ctx, deletePlayerScenePreset, arg.ID, arg.ProducerID)
	return err
}

const getPlayerScenePresetByID = `-- name: GetPlayerScenePresetByID :one
SELECT id, producer_id, name, scene, created_at, updated_at FROM player_scene_presets
WHERE id = $1
`

// GetPlayerScenePresetByID
//
//	SELECT id, producer_id, name, scene, created_at, updated_at FROM player_scene_presets
//	WHERE id = $1
func (q *Queries) GetPlayerScenePresetByID(ctx context.Context, id pgtype.UUID) (*PlayerScenePreset, error) {
	row := q.db.QueryRow(ctx, getPlayerScenePresetByID, id)
	var i PlayerScenePreset
	err := row.Scan(
		&i.ID,
		&i.ProducerID,
		&i.Name,
		&i.Scene,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listPlayerScenePresetsByProducer = `-- name: ListPlayerScenePresetsByProducer :many
SELECT id, producer_id, name, scene, created_at, updated_at FROM player_scene_presets
WHERE producer_id = $1
ORDER BY updated_at DESC
`

// ListPlayerScenePresetsByProducer
//
//	SELECT id, producer_id, name, scene, created_at, updated_at FROM player_scene_presets
//	WHERE producer_id = $1
//	ORDER BY updated_at DESC
func (q *Queries) ListPlayerScenePresetsByProducer(ctx context.Context, producerID pgtype.UUID) ([]*PlayerScenePreset, error) {
	rows, err := q.db.Query(ctx, listPlayerScenePresetsByProducer, producerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*PlayerScenePreset
	for rows.Next() {
		var i PlayerScenePreset
		if err := rows.Scan(
			&i.ID,
			&i.ProducerID,
			&i.Name,
			&i.Scene,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertPlayerScenePreset = `-- name: UpsertPlayerScenePreset :one
INSERT INTO player_scene_presets (producer_id, name, scene)
VALUES ($1, $2, $3)
ON CONFLICT (producer_id, name)
DO UPDATE SET scene = EXCLUDED.scene, updated_at = NOW()
RETURNING id, producer_id, name, scene, created_at, updated_at
`

type UpsertPlayerScenePresetParams struct {
	ProducerID pgtype.UUID `db:"producer_id" json:"ProducerID"`
	Name       string      `db:"name" json:"Name"`
	Scene      []byte      `db:"scene" json:"Scene"`
}

// UpsertPlayerScenePreset
//
//	INSERT INTO player_scene_presets (producer_id, name, scene)
//	VALUES ($1, $2, $3)
//	ON CONFLICT (producer_id, name)
//	DO UPDATE SET scene = EXCLUDED.scene, updated_at = NOW()
//	RETURNING id, producer_id, name, scene, created_at, updated_at
func (q *Queries) UpsertPlayerScenePreset(ctx context.Context, arg *UpsertPlayerScenePresetParams) (*PlayerScenePreset, error) {
	row := q.db.QueryRow(ctx, upsertPlayerScenePreset, arg.ProducerID, arg.Name, arg.Scene)
	var i PlayerScenePreset
	err := row.Scan(
		&i.ID,
		&i.ProducerID,
		&i.Name,
		&i.Scene,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
