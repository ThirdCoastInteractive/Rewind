// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type Querier interface {
	// Releases a PostgreSQL advisory lock
	// Returns true if the lock was released, false if it wasn't held
	//
	//  SELECT pg_advisory_unlock($1::bigint) AS unlocked
	AdvisoryUnlock(ctx context.Context, lockID int64) (bool, error)
	// ArchiveJob marks a job as archived (soft delete).
	//
	//  UPDATE download_jobs
	//  SET archived = TRUE,
	//      updated_at = NOW()
	//  WHERE id = $1
	ArchiveJob(ctx context.Context, id pgtype.UUID) error
	// ArchiveJobs marks multiple jobs as archived (batch operation).
	//
	//  UPDATE download_jobs
	//  SET archived = TRUE,
	//      updated_at = NOW()
	//  WHERE id = ANY($1::uuid[])
	ArchiveJobs(ctx context.Context, jobIds []pgtype.UUID) error
	// CancelDownloadJob marks a job as cancelled.
	//
	//  UPDATE download_jobs
	//  SET status = 'failed',
	//      last_error = 'Cancelled by user',
	//      finished_at = NOW(),
	//      process_pid = NULL,
	//      updated_at = NOW()
	//  WHERE id = $1
	CancelDownloadJob(ctx context.Context, id pgtype.UUID) error
	// ClearAllVideoAssetErrors resets error tracking for all videos so catchup retries them.
	//
	//  UPDATE videos
	//  SET assets_status = assets_status - '_error_count' - '_last_error_at' - '_errors',
	//      updated_at = NOW()
	//  WHERE assets_status ? '_error_count'
	//  AND (assets_status->>'_error_count')::int > 0
	ClearAllVideoAssetErrors(ctx context.Context) error
	// Clear the PID when process completes
	//
	//  UPDATE clip_exports
	//  SET pid = NULL,
	//      updated_at = NOW()
	//  WHERE id = $1
	ClearClipExportPID(ctx context.Context, id pgtype.UUID) error
	// ClearVideoAssetErrors resets error tracking for a single video so catchup retries it.
	//
	//  UPDATE videos
	//  SET assets_status = assets_status - '_error_count' - '_last_error_at' - '_errors',
	//      updated_at = NOW()
	//  WHERE id = $1
	ClearVideoAssetErrors(ctx context.Context, id pgtype.UUID) error
	// ClearVideoFromJobs sets video_id to NULL for all jobs referencing this video.
	//
	//  UPDATE download_jobs
	//  SET video_id = NULL,
	//      updated_at = NOW()
	//  WHERE video_id = $1
	ClearVideoFromJobs(ctx context.Context, videoID pgtype.UUID) error
	//ClearVideoFromPlayerSessions
	//
	//  UPDATE player_sessions
	//  SET current_video_id = NULL, last_activity = NOW()
	//  WHERE current_video_id = $1
	ClearVideoFromPlayerSessions(ctx context.Context, videoID pgtype.UUID) error
	//CountClipExports
	//
	//  SELECT COUNT(*) FROM clip_exports
	CountClipExports(ctx context.Context) (int64, error)
	// CountEnabledAdmins counts enabled admin users
	//
	//  SELECT COUNT(*)::bigint FROM users WHERE deleted_at IS NULL AND enabled = TRUE AND role = 'admin'
	CountEnabledAdmins(ctx context.Context) (int64, error)
	// CountUserCookies counts the number of cookies for a user
	//
	//  SELECT COUNT(*) as count
	//  FROM cookies
	//  WHERE user_id = $1
	CountUserCookies(ctx context.Context, userID pgtype.UUID) (int64, error)
	// CountUsers counts non-deleted users
	//
	//  SELECT COUNT(*)::bigint FROM users WHERE deleted_at IS NULL
	CountUsers(ctx context.Context) (int64, error)
	// CountVideoComments returns total comments ingested for a video.
	//
	//  SELECT COUNT(*)
	//  FROM video_comments
	//  WHERE video_id = $1
	CountVideoComments(ctx context.Context, videoID pgtype.UUID) (int64, error)
	// CountVideosWithAssetErrors returns the number of videos with asset generation errors.
	//
	//  SELECT COUNT(*)
	//  FROM videos
	//  WHERE video_path IS NOT NULL AND btrim(video_path) <> ''
	//  AND assets_status ? '_error_count'
	//  AND (assets_status->>'_error_count')::int > 0
	CountVideosWithAssetErrors(ctx context.Context) (int64, error)
	// CountVideosWithVideoPath returns count of videos that have a video_path.
	//
	//  SELECT COUNT(*)
	//  FROM videos
	//  WHERE video_path IS NOT NULL AND btrim(video_path) <> ''
	CountVideosWithVideoPath(ctx context.Context) (int64, error)
	//CountYtdlpLogsForJob
	//
	//  SELECT COUNT(*) FROM ytdlp_logs WHERE job_id = $1
	CountYtdlpLogsForJob(ctx context.Context, jobID pgtype.UUID) (int64, error)
	//CreateClip
	//
	//  INSERT INTO clips (
	//      video_id,
	//      start_ts,
	//      end_ts,
	//      duration,
	//      title,
	//      description,
	//      color,
	//      tags,
	//      created_by
	//  ) VALUES (
	//      $1,
	//      $2,
	//      $3,
	//      $4,
	//      $5,
	//      $6,
	//      $7,
	//      $8,
	//      $9
	//  ) RETURNING id, video_id, start_ts, end_ts, duration, created_at, updated_at, created_by, title, description, color, tags, crops, filter_stack
	CreateClip(ctx context.Context, arg *CreateClipParams) (*Clip, error)
	//CreateClipExport
	//
	//  INSERT INTO clip_exports (clip_id, created_by, format, variant, spec, clip_updated_at, file_path, status, created_at, updated_at)
	//  VALUES ($1, $2, $3, $4, $5, $6, '', 'queued', NOW(), NOW())
	//  RETURNING id
	CreateClipExport(ctx context.Context, arg *CreateClipExportParams) (pgtype.UUID, error)
	//CreateExtensionToken
	//
	//  INSERT INTO extension_tokens (user_id, token, expires_at)
	//  VALUES ($1, $2, $3)
	//  RETURNING id, user_id, token, created_at, last_used_at, expires_at, revoked
	CreateExtensionToken(ctx context.Context, arg *CreateExtensionTokenParams) (*ExtensionToken, error)
	//CreateMarker
	//
	//  INSERT INTO markers (
	//      video_id,
	//      timestamp,
	//      title,
	//      description,
	//      color,
	//      marker_type,
	//      duration,
	//      created_by
	//  ) VALUES (
	//      $1,
	//      $2,
	//      $3,
	//      $4,
	//      $5,
	//      $6,
	//      $7,
	//      $8
	//  ) RETURNING id, video_id, timestamp, title, description, color, marker_type, duration, created_at, created_by
	CreateMarker(ctx context.Context, arg *CreateMarkerParams) (*Marker, error)
	//CreatePlayerSession
	//
	//  INSERT INTO player_sessions (producer_id, session_code, expires_at)
	//  VALUES ($1, $2, $3)
	//  RETURNING id, session_code, producer_id, current_video_id, state, created_at, expires_at, last_activity
	CreatePlayerSession(ctx context.Context, arg *CreatePlayerSessionParams) (*PlayerSession, error)
	// Delete all exports (files must be cleaned up separately)
	//
	//  DELETE FROM clip_exports
	DeleteAllClipExports(ctx context.Context) error
	//DeleteClip
	//
	//  DELETE FROM clips
	//  WHERE id = $1
	DeleteClip(ctx context.Context, id pgtype.UUID) error
	//DeleteClipExport
	//
	//  DELETE FROM clip_exports WHERE id = $1
	DeleteClipExport(ctx context.Context, id pgtype.UUID) error
	// Delete exports by status (files must be cleaned up separately)
	//
	//  DELETE FROM clip_exports WHERE status = $1
	DeleteClipExportsByStatus(ctx context.Context, status ExportStatus) error
	//DeleteClipsByVideo
	//
	//  DELETE FROM clips
	//  WHERE video_id = $1
	DeleteClipsByVideo(ctx context.Context, videoID pgtype.UUID) error
	//DeleteMarker
	//
	//  DELETE FROM markers
	//  WHERE id = $1
	DeleteMarker(ctx context.Context, id pgtype.UUID) error
	//DeleteMarkersByVideo
	//
	//  DELETE FROM markers
	//  WHERE video_id = $1
	DeleteMarkersByVideo(ctx context.Context, videoID pgtype.UUID) error
	//DeletePlayerScenePreset
	//
	//  DELETE FROM player_scene_presets
	//  WHERE id = $1 AND producer_id = $2
	DeletePlayerScenePreset(ctx context.Context, arg *DeletePlayerScenePresetParams) error
	//DeletePlayerSession
	//
	//  DELETE FROM player_sessions
	//  WHERE id = $1
	DeletePlayerSession(ctx context.Context, id pgtype.UUID) error
	// DeleteUser soft deletes a user from the database
	//
	//  UPDATE users SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL
	DeleteUser(ctx context.Context, id pgtype.UUID) error
	// DeleteUserCookies deletes all cookies for a user
	//
	//  DELETE FROM cookies
	//  WHERE user_id = $1
	DeleteUserCookies(ctx context.Context, userID pgtype.UUID) error
	//DeleteUserKeybinding
	//
	//  DELETE FROM user_keybindings
	//  WHERE user_id = $1 AND action = $2
	DeleteUserKeybinding(ctx context.Context, arg *DeleteUserKeybindingParams) error
	// DeleteVideo deletes a video by ID (cascades to related records).
	//
	//  DELETE FROM videos
	//  WHERE id = $1
	DeleteVideo(ctx context.Context, id pgtype.UUID) error
	// DequeueDownloadJob claims one queued download job.
	//
	//  WITH cte AS (
	//      SELECT id
	//      FROM download_jobs
	//      WHERE status = 'queued'
	//      ORDER BY created_at
	//      LIMIT 1
	//      FOR UPDATE SKIP LOCKED
	//  )
	//  UPDATE download_jobs
	//  SET status = 'processing',
	//      attempts = attempts + 1,
	//      started_at = COALESCE(started_at, NOW()),
	//      updated_at = NOW()
	//  WHERE id IN (SELECT id FROM cte)
	//  RETURNING id, created_at, updated_at, url, archived_by, status, attempts, last_error, started_at, finished_at, spool_dir, info_json_path, video_id, refresh, process_pid, archived, extra_args
	DequeueDownloadJob(ctx context.Context) (*DownloadJob, error)
	// DequeueIngestJob claims one queued ingest job and returns needed info.
	// Returns video_id for asset regeneration jobs (NULL for normal ingest).
	// Skips jobs that have already been retried too many times.
	//
	//  WITH cte AS (
	//      SELECT id
	//      FROM ingest_jobs
	//      WHERE status = 'queued'
	//        AND attempts < 5
	//      ORDER BY created_at
	//      LIMIT 1
	//      FOR UPDATE SKIP LOCKED
	//  )
	//  UPDATE ingest_jobs AS ij
	//  SET status = 'processing',
	//      attempts = ij.attempts + 1,
	//      started_at = COALESCE(ij.started_at, NOW()),
	//      updated_at = NOW()
	//  FROM download_jobs AS dj
	//  WHERE ij.id IN (SELECT id FROM cte)
	//    AND dj.id = ij.download_job_id
	//  RETURNING
	//      ij.id AS ingest_job_id,
	//      ij.download_job_id,
	//      dj.url AS url,
	//      dj.archived_by AS archived_by,
	//      dj.refresh AS refresh,
	//      dj.spool_dir AS spool_dir,
	//      dj.info_json_path AS info_json_path,
	//      dj.video_id AS video_id,
	//      ij.asset_scope AS asset_scope,
	//      dj.extra_args AS extra_args
	DequeueIngestJob(ctx context.Context) (*DequeueIngestJobRow, error)
	// EmailRegistered checks if an email is already registered
	//
	//  SELECT EXISTS (
	//      SELECT 1
	//      FROM users
	//      WHERE email = $1 AND deleted_at IS NULL
	//  )
	EmailRegistered(ctx context.Context, email string) (bool, error)
	// EnqueueAssetRegenerationJob creates a download + ingest job pair for regenerating assets.
	// asset_scope: NULL = all assets, or one of 'thumbnail', 'preview', 'seek', 'waveform'.
	//
	//  WITH new_download_job AS (
	//      INSERT INTO download_jobs (
	//          url,
	//          archived_by,
	//          refresh,
	//          status,
	//          video_id
	//      )
	//      SELECT
	//          v.src,
	//          v.archived_by,
	//          true,
	//          'succeeded',
	//          v.id
	//      FROM videos v
	//      WHERE v.id = $1
	//      RETURNING id, created_at, updated_at, url, archived_by, status, attempts, last_error, started_at, finished_at, spool_dir, info_json_path, video_id, refresh, process_pid, archived, extra_args
	//  ),
	//  new_ingest_job AS (
	//      INSERT INTO ingest_jobs (
	//          download_job_id,
	//          status,
	//          asset_scope
	//      )
	//      SELECT
	//          new_download_job.id,
	//          'queued',
	//          $2::text
	//      FROM new_download_job
	//      RETURNING id, created_at, updated_at, download_job_id, status, attempts, last_error, started_at, finished_at, asset_scope
	//  )
	//  SELECT
	//      new_ingest_job.id AS ingest_job_id,
	//      new_download_job.id AS download_job_id,
	//      new_download_job.video_id AS video_id
	//  FROM new_ingest_job, new_download_job
	EnqueueAssetRegenerationJob(ctx context.Context, arg *EnqueueAssetRegenerationJobParams) (*EnqueueAssetRegenerationJobRow, error)
	// EnqueueDownloadJob inserts a new download job.
	//
	//  INSERT INTO download_jobs (
	//      url,
	//      archived_by,
	//      status,
	//      refresh,
	//      extra_args
	//  )
	//  VALUES (
	//      $1,
	//      $2,
	//      'queued',
	//      $3,
	//      $4
	//  )
	//  RETURNING id, created_at, updated_at, url, archived_by, status, attempts, last_error, started_at, finished_at, spool_dir, info_json_path, video_id, refresh, process_pid, archived, extra_args
	EnqueueDownloadJob(ctx context.Context, arg *EnqueueDownloadJobParams) (*DownloadJob, error)
	// EnqueueIngestJob inserts a new ingest job from a download job.
	//
	//  INSERT INTO ingest_jobs (
	//      download_job_id,
	//      status
	//  )
	//  VALUES (
	//      $1,
	//      'queued'
	//  )
	//  RETURNING id, created_at, updated_at, download_job_id, status, attempts, last_error, started_at, finished_at, asset_scope
	EnqueueIngestJob(ctx context.Context, downloadJobID pgtype.UUID) (*IngestJob, error)
	// FailExcessiveRetryIngestJobs permanently fails jobs that have been retried too many times.
	// This prevents zombie jobs from wasting workers indefinitely.
	//
	//  UPDATE ingest_jobs
	//  SET status = 'failed',
	//      last_error = 'exceeded maximum retry attempts',
	//      finished_at = NOW(),
	//      updated_at = NOW()
	//  WHERE status = 'queued'
	//    AND attempts >= 5
	FailExcessiveRetryIngestJobs(ctx context.Context) (int64, error)
	// ============================================================================
	// ENCODER WORKER QUERIES
	// ============================================================================
	// Atomically find the oldest queued export and lock it for processing.
	// Uses FOR UPDATE SKIP LOCKED so concurrent workers never claim the same row.
	//
	//
	//  UPDATE clip_exports
	//  SET status = 'processing',
	//      locked_at = NOW(),
	//      locked_by = $1,
	//      started_at = NOW(),
	//      attempts = attempts + 1,
	//      updated_at = NOW()
	//  WHERE id = (
	//      SELECT id FROM clip_exports
	//      WHERE status = 'queued'
	//        AND (locked_at IS NULL OR locked_at < NOW() - INTERVAL '10 minutes')
	//      ORDER BY created_at ASC
	//      LIMIT 1
	//      FOR UPDATE SKIP LOCKED
	//  )
	//  RETURNING id, clip_id, created_by, format, variant, spec, clip_updated_at
	FindAndLockPendingClipExport(ctx context.Context, lockedBy *string) (*FindAndLockPendingClipExportRow, error)
	// Find existing queued/processing export that is NOT stuck (updated in last 5 minutes)
	//
	//  SELECT id, status, progress_pct, file_path
	//  FROM clip_exports
	//  WHERE clip_id = $1
	//    AND created_by = $2
	//    AND format = $3
	//    AND variant = $4
	//    AND status IN ('queued', 'processing')
	//    AND updated_at > NOW() - INTERVAL '5 minutes'
	//  ORDER BY created_at DESC
	//  LIMIT 1
	FindOrCreatePendingClipExport(ctx context.Context, arg *FindOrCreatePendingClipExportParams) (*FindOrCreatePendingClipExportRow, error)
	// Find processing exports with PIDs that belong to this worker (for cleanup on restart)
	//
	//  SELECT id, pid, file_path
	//  FROM clip_exports
	//  WHERE status = 'processing'
	//    AND locked_by = $1
	//    AND pid IS NOT NULL
	FindOrphanedExportsWithPID(ctx context.Context, lockedBy *string) ([]*FindOrphanedExportsWithPIDRow, error)
	// Find ready exports to check for missing files (for cleanup/requeue on startup)
	//
	//  SELECT id, file_path, clip_id
	//  FROM clip_exports
	//  WHERE status = 'ready'
	//    AND file_path != ''
	//  ORDER BY created_at DESC
	//  LIMIT 500
	FindReadyExportsWithMissingFiles(ctx context.Context) ([]*FindReadyExportsWithMissingFilesRow, error)
	//FindReusableClipExport
	//
	//  SELECT id, file_path
	//  FROM clip_exports
	//  WHERE clip_exports.clip_id = $1
	//    AND clip_exports.created_by = $2
	//    AND clip_exports.format = $3
	//    AND clip_exports.variant = $4
	//    AND clip_exports.status = 'ready'
	//    AND clip_exports.clip_updated_at >= (SELECT clips.updated_at FROM clips WHERE clips.id = $1)
	//  ORDER BY clip_exports.created_at DESC
	//  LIMIT 1
	FindReusableClipExport(ctx context.Context, arg *FindReusableClipExportParams) (*FindReusableClipExportRow, error)
	// Mark export as failed with error message
	//
	//  UPDATE clip_exports
	//  SET status = 'error',
	//      last_error = $1,
	//      finished_at = NOW(),
	//      locked_at = NULL,
	//      locked_by = NULL,
	//      pid = NULL,
	//      updated_at = NOW()
	//  WHERE id = $2
	FinishClipExportError(ctx context.Context, arg *FinishClipExportErrorParams) error
	// Mark export as ready with file info
	//
	//  UPDATE clip_exports
	//  SET status = 'ready',
	//      file_path = $1,
	//      size_bytes = $2,
	//      progress_pct = 100,
	//      finished_at = NOW(),
	//      locked_at = NULL,
	//      locked_by = NULL,
	//      pid = NULL,
	//      last_accessed_at = NOW(),
	//      updated_at = NOW()
	//  WHERE id = $3
	FinishClipExportReady(ctx context.Context, arg *FinishClipExportReadyParams) error
	// GetActiveAssetJobsForVideo returns active (queued/processing) ingest jobs
	// for a given video, including both normal post-ingest and regen jobs.
	// asset_scope is NULL for "all assets" jobs, or one of thumbnail/preview/seek/waveform.
	//
	//  SELECT ij.id AS ingest_job_id,
	//         ij.asset_scope,
	//         ij.status
	//  FROM ingest_jobs ij
	//  JOIN download_jobs dj ON dj.id = ij.download_job_id
	//  WHERE dj.video_id = $1
	//    AND ij.status IN ('queued', 'processing')
	GetActiveAssetJobsForVideo(ctx context.Context, videoID pgtype.UUID) ([]*GetActiveAssetJobsForVideoRow, error)
	//GetActiveSessionByProducer
	//
	//  SELECT id, session_code, producer_id, current_video_id, state, created_at, expires_at, last_activity FROM player_sessions
	//  WHERE producer_id = $1 AND expires_at > NOW()
	//  ORDER BY created_at DESC
	//  LIMIT 1
	GetActiveSessionByProducer(ctx context.Context, producerID pgtype.UUID) (*PlayerSession, error)
	//GetClip
	//
	//  SELECT id, video_id, start_ts, end_ts, duration, created_at, updated_at, created_by, title, description, color, tags, crops, filter_stack FROM clips
	//  WHERE id = $1
	GetClip(ctx context.Context, id pgtype.UUID) (*Clip, error)
	//GetClipExportByID
	//
	//  SELECT id, file_path, status, last_error
	//  FROM clip_exports
	//  WHERE id = $1
	GetClipExportByID(ctx context.Context, id pgtype.UUID) (*GetClipExportByIDRow, error)
	//GetClipExportForDownload
	//
	//  SELECT ce.file_path, ce.format, ce.status, ce.clip_id, ce.variant,
	//         COALESCE(c.title, '') AS clip_title,
	//         c.crops
	//  FROM clip_exports ce
	//  JOIN clips c ON c.id = ce.clip_id
	//  WHERE ce.id = $1
	GetClipExportForDownload(ctx context.Context, id pgtype.UUID) (*GetClipExportForDownloadRow, error)
	// Get export statistics for admin dashboard
	//
	//  SELECT
	//      COUNT(*) FILTER (WHERE status = 'queued') AS queued_count,
	//      COUNT(*) FILTER (WHERE status = 'processing') AS processing_count,
	//      COUNT(*) FILTER (WHERE status = 'ready') AS ready_count,
	//      COUNT(*) FILTER (WHERE status = 'error') AS error_count,
	//      COALESCE(SUM(size_bytes) FILTER (WHERE status = 'ready'), 0)::bigint AS total_size_bytes
	//  FROM clip_exports
	GetClipExportStats(ctx context.Context) (*GetClipExportStatsRow, error)
	// Get current export status for SSE streaming
	//
	//  SELECT id, clip_id, status, progress_pct, file_path, last_error
	//  FROM clip_exports
	//  WHERE id = $1
	GetClipExportStatus(ctx context.Context, id pgtype.UUID) (*GetClipExportStatusRow, error)
	//GetClipExportStorageLimit
	//
	//  SELECT COALESCE(clip_export_storage_limit_bytes, 0) FROM instance_settings WHERE id = 1
	GetClipExportStorageLimit(ctx context.Context) (int64, error)
	// Get clip data needed for encoding
	//
	//  SELECT c.id, c.video_id, c.start_ts, c.end_ts, c.duration, c.crops, c.filter_stack,
	//         c.title AS clip_title, v.video_path
	//  FROM clips c
	//  JOIN videos v ON v.id = c.video_id
	//  WHERE c.id = $1
	GetClipForExport(ctx context.Context, id pgtype.UUID) (*GetClipForExportRow, error)
	// ============================================================================
	// Admin Dashboard Metrics
	// ============================================================================
	// GetDashboardOverview returns high-level counts and totals for the admin dashboard.
	//
	//
	//  SELECT
	//      (SELECT COUNT(*)::bigint FROM videos) AS total_videos,
	//      (SELECT COUNT(*)::bigint FROM clips) AS total_clips,
	//      (SELECT COUNT(*)::bigint FROM markers) AS total_markers,
	//      (SELECT COUNT(*)::bigint FROM users WHERE deleted_at IS NULL) AS total_users,
	//      (SELECT COUNT(*)::bigint FROM video_comments) AS total_comments,
	//      (SELECT COALESCE(SUM(file_size), 0)::bigint FROM videos WHERE file_size IS NOT NULL) AS total_storage_bytes,
	//      (SELECT COALESCE(SUM(duration_seconds), 0)::bigint FROM videos WHERE duration_seconds IS NOT NULL) AS total_duration_seconds
	GetDashboardOverview(ctx context.Context) (*GetDashboardOverviewRow, error)
	// GetDownloadJobByID returns a download job by ID
	//
	//  SELECT id, created_at, updated_at, url, archived_by, status, attempts, last_error, started_at, finished_at, spool_dir, info_json_path, video_id, refresh, process_pid, archived, extra_args
	//  FROM download_jobs
	//  WHERE id = $1
	GetDownloadJobByID(ctx context.Context, id pgtype.UUID) (*DownloadJob, error)
	// GetDownloadJobPID retrieves the process ID for a job.
	//
	//  SELECT process_pid
	//  FROM download_jobs
	//  WHERE id = $1
	GetDownloadJobPID(ctx context.Context, id pgtype.UUID) (*int64, error)
	//GetExtensionTokenByToken
	//
	//  SELECT id, user_id, token, created_at, last_used_at, expires_at, revoked FROM extension_tokens
	//  WHERE token = $1 AND NOT revoked AND expires_at > NOW()
	GetExtensionTokenByToken(ctx context.Context, token string) (*ExtensionToken, error)
	// GetInstanceSettings fetches the single instance settings row
	//
	//  SELECT id, registration_enabled, clip_export_storage_limit_bytes, admin_emails, updated_at FROM instance_settings WHERE id = 1
	GetInstanceSettings(ctx context.Context) (*InstanceSetting, error)
	// GetJobStatusCounts returns download and ingest job counts grouped by status.
	//
	//  SELECT
	//      'download' AS job_type,
	//      status::text AS status,
	//      COUNT(*)::bigint AS count
	//  FROM download_jobs
	//  GROUP BY status
	//  UNION ALL
	//  SELECT
	//      'ingest' AS job_type,
	//      status::text AS status,
	//      COUNT(*)::bigint AS count
	//  FROM ingest_jobs
	//  GROUP BY status
	//  ORDER BY job_type, status
	GetJobStatusCounts(ctx context.Context) ([]*GetJobStatusCountsRow, error)
	//GetMarker
	//
	//  SELECT id, video_id, timestamp, title, description, color, marker_type, duration, created_at, created_by FROM markers
	//  WHERE id = $1
	GetMarker(ctx context.Context, id pgtype.UUID) (*Marker, error)
	// GetPlaybackPosition retrieves the last playback position for a user/video
	//
	//  SELECT position_seconds, updated_at
	//  FROM playback_positions
	//  WHERE user_id = $1
	//    AND video_id = $2
	GetPlaybackPosition(ctx context.Context, arg *GetPlaybackPositionParams) (*GetPlaybackPositionRow, error)
	//GetPlayerScenePresetByID
	//
	//  SELECT id, producer_id, name, scene, created_at, updated_at FROM player_scene_presets
	//  WHERE id = $1
	GetPlayerScenePresetByID(ctx context.Context, id pgtype.UUID) (*PlayerScenePreset, error)
	//GetPlayerSessionByCode
	//
	//  SELECT id, session_code, producer_id, current_video_id, state, created_at, expires_at, last_activity FROM player_sessions
	//  WHERE session_code = $1 AND expires_at > NOW()
	GetPlayerSessionByCode(ctx context.Context, sessionCode string) (*PlayerSession, error)
	//GetPlayerSessionByID
	//
	//  SELECT id, session_code, producer_id, current_video_id, state, created_at, expires_at, last_activity FROM player_sessions
	//  WHERE id = $1
	GetPlayerSessionByID(ctx context.Context, id pgtype.UUID) (*PlayerSession, error)
	// GetSessionInvalidation returns the sessions_invalidated_at and enabled
	// flag for a user. Used by middleware to check if a session is still valid.
	//
	//  SELECT sessions_invalidated_at, enabled
	//  FROM users
	//  WHERE id = $1 AND deleted_at IS NULL
	GetSessionInvalidation(ctx context.Context, id pgtype.UUID) (*GetSessionInvalidationRow, error)
	// GetStorageByUploader returns total file storage grouped by uploader.
	//
	//  SELECT
	//      (CASE WHEN uploader = '' THEN 'unknown' ELSE uploader END)::text AS uploader,
	//      COALESCE(SUM(file_size), 0)::bigint AS total_bytes
	//  FROM videos
	//  WHERE file_size IS NOT NULL
	//  GROUP BY uploader
	//  ORDER BY total_bytes DESC
	//  LIMIT 10
	GetStorageByUploader(ctx context.Context) ([]*GetStorageByUploaderRow, error)
	// GetTopSources returns the top video sources (platforms) by count.
	//
	//  SELECT
	//      COALESCE(
	//          regexp_replace(src, 'https?://(?:www\.)?([^/]+).*', '\1'),
	//          'unknown'
	//      )::text AS source,
	//      COUNT(*)::bigint AS count
	//  FROM videos
	//  GROUP BY source
	//  ORDER BY count DESC
	//  LIMIT 10
	GetTopSources(ctx context.Context) ([]*GetTopSourcesRow, error)
	//GetTotalClipExportSize
	//
	//  SELECT COALESCE(SUM(size_bytes), 0)::bigint FROM clip_exports WHERE status = 'ready'
	GetTotalClipExportSize(ctx context.Context) (int64, error)
	// GetUserCookies returns all cookies for a user in Netscape format
	//
	//  SELECT domain, flag, path, secure, expiration, name, value
	//  FROM cookies
	//  WHERE user_id = $1
	//  ORDER BY domain, name, path
	GetUserCookies(ctx context.Context, userID pgtype.UUID) ([]*GetUserCookiesRow, error)
	//GetUserKeybindings
	//
	//  SELECT action, key
	//  FROM user_keybindings
	//  WHERE user_id = $1
	GetUserKeybindings(ctx context.Context, userID pgtype.UUID) ([]*GetUserKeybindingsRow, error)
	// GetVideoByID returns a video by ID
	//
	//  SELECT id, created_at, updated_at, src, archived_by, title, info, comments, video_path, thumbnail_path, description, tags, uploader, uploader_id, channel_id, upload_date, duration_seconds, view_count, like_count, thumb_gradient_start, thumb_gradient_end, thumb_gradient_angle, file_hash, file_size, assets_status, search, probe_data
	//  FROM videos
	//  WHERE id = $1
	GetVideoByID(ctx context.Context, id pgtype.UUID) (*Video, error)
	// GetVideoWithDownloadJob gets a video with its download job info for playback
	//
	//  SELECT
	//      v.id as video_id,
	//      v.src,
	//      v.title,
	//      v.info,
	//      v.comments,
	//      v.video_path,
	//      v.thumbnail_path,
	//      v.created_at as video_created_at,
	//      v.updated_at as video_updated_at,
	//      dj.id as download_job_id,
	//      dj.spool_dir,
	//      dj.info_json_path
	//  FROM videos v
	//  LEFT JOIN download_jobs dj ON dj.video_id = v.id
	//  WHERE v.id = $1
	GetVideoWithDownloadJob(ctx context.Context, videoID pgtype.UUID) (*GetVideoWithDownloadJobRow, error)
	// GetVideosPerDay returns the number of videos archived per day for the last N days.
	//
	//  SELECT
	//      d.day::date AS day,
	//      COUNT(v.id)::bigint AS count
	//  FROM generate_series(
	//      CURRENT_DATE - ($1::int - 1) * INTERVAL '1 day',
	//      CURRENT_DATE,
	//      '1 day'
	//  ) AS d(day)
	//  LEFT JOIN videos v ON v.created_at::date = d.day::date
	//  GROUP BY d.day
	//  ORDER BY d.day
	GetVideosPerDay(ctx context.Context, days int32) ([]*GetVideosPerDayRow, error)
	//GetYtdlpLogsForJob
	//
	//  SELECT id, job_id, stream, message, created_at
	//  FROM ytdlp_logs
	//  WHERE job_id = $1
	//  ORDER BY created_at ASC, id ASC
	GetYtdlpLogsForJob(ctx context.Context, jobID pgtype.UUID) ([]*YtdlpLog, error)
	//GetYtdlpLogsForJobPaginated
	//
	//  SELECT id, job_id, stream, message, created_at
	//  FROM ytdlp_logs
	//  WHERE job_id = $1
	//  ORDER BY created_at DESC, id DESC
	//  LIMIT $3 OFFSET $2
	GetYtdlpLogsForJobPaginated(ctx context.Context, arg *GetYtdlpLogsForJobPaginatedParams) ([]*YtdlpLog, error)
	//GetYtdlpLogsForJobSince
	//
	//  SELECT id, job_id, stream, message, created_at
	//  FROM ytdlp_logs
	//  WHERE job_id = $1 AND created_at > $2
	//  ORDER BY created_at ASC, id ASC
	GetYtdlpLogsForJobSince(ctx context.Context, arg *GetYtdlpLogsForJobSinceParams) ([]*YtdlpLog, error)
	// InsertCookie inserts a new cookie for a user
	//
	//  INSERT INTO cookies (user_id, domain, flag, path, secure, expiration, name, value)
	//  VALUES (
	//      $1,
	//      $2,
	//      $3,
	//      $4,
	//      $5,
	//      $6,
	//      $7,
	//      $8
	//  )
	//  ON CONFLICT (user_id, domain, name, path)
	//  DO UPDATE SET
	//      flag = EXCLUDED.flag,
	//      secure = EXCLUDED.secure,
	//      expiration = EXCLUDED.expiration,
	//      value = EXCLUDED.value,
	//      updated_at = NOW()
	InsertCookie(ctx context.Context, arg *InsertCookieParams) error
	// InsertVideo inserts a video row.
	//
	//  INSERT INTO videos (
	//      id,
	//      src,
	//      archived_by,
	//      title,
	//      thumb_gradient_start,
	//      thumb_gradient_end,
	//      thumb_gradient_angle,
	//      description,
	//      tags,
	//      uploader,
	//      uploader_id,
	//      channel_id,
	//      upload_date,
	//      duration_seconds,
	//      view_count,
	//      like_count,
	//      info,
	//      comments,
	//      video_path,
	//      thumbnail_path,
	//      file_hash,
	//      file_size,
	//      probe_data,
	//      search
	//  )
	//  VALUES (
	//      $1,
	//      $2,
	//      $3,
	//      $4,
	//      $5,
	//      $6,
	//      $7,
	//      $8,
	//      $9,
	//      $10,
	//      $11,
	//      $12,
	//      CASE
	//          WHEN ($13::text) IS NULL OR btrim($13::text) = '' THEN NULL
	//          WHEN ($13::text) ~ '^[0-9]{8}$' THEN to_date($13::text, 'YYYYMMDD')
	//          ELSE ($13::text)::date
	//      END,
	//      $14,
	//      $15,
	//      $16,
	//      $17,
	//      $18,
	//      $19,
	//      $20,
	//      $21,
	//      $22,
	//      $23,
	//      to_tsvector('simple'::regconfig,
	//          coalesce($4, '') || ' ' ||
	//          coalesce($8, '') || ' ' ||
	//          coalesce(array_to_string($9::text[], ' '), '')
	//      )
	//  )
	//  ON CONFLICT (src)
	//  DO UPDATE SET
	//      updated_at = NOW(),
	//      title = EXCLUDED.title,
	//      thumb_gradient_start = COALESCE(EXCLUDED.thumb_gradient_start, videos.thumb_gradient_start),
	//      thumb_gradient_end = COALESCE(EXCLUDED.thumb_gradient_end, videos.thumb_gradient_end),
	//      thumb_gradient_angle = COALESCE(EXCLUDED.thumb_gradient_angle, videos.thumb_gradient_angle),
	//      description = EXCLUDED.description,
	//      tags = EXCLUDED.tags,
	//      uploader = EXCLUDED.uploader,
	//      uploader_id = EXCLUDED.uploader_id,
	//      channel_id = EXCLUDED.channel_id,
	//      upload_date = EXCLUDED.upload_date,
	//      duration_seconds = EXCLUDED.duration_seconds,
	//      view_count = EXCLUDED.view_count,
	//      like_count = EXCLUDED.like_count,
	//      info = EXCLUDED.info,
	//      comments = EXCLUDED.comments,
	//      video_path = EXCLUDED.video_path,
	//      thumbnail_path = EXCLUDED.thumbnail_path,
	//      file_hash = EXCLUDED.file_hash,
	//      file_size = EXCLUDED.file_size,
	//      probe_data = COALESCE(EXCLUDED.probe_data, videos.probe_data),
	//      search = EXCLUDED.search
	//  RETURNING id, created_at, updated_at, src, archived_by, title, info, comments, video_path, thumbnail_path, description, tags, uploader, uploader_id, channel_id, upload_date, duration_seconds, view_count, like_count, thumb_gradient_start, thumb_gradient_end, thumb_gradient_angle, file_hash, file_size, assets_status, search, probe_data
	InsertVideo(ctx context.Context, arg *InsertVideoParams) (*Video, error)
	// InsertVideoRevision stores a refresh diff.
	//
	//  INSERT INTO video_revisions (
	//      video_id,
	//      kind,
	//      diff,
	//      old_title,
	//      new_title,
	//      old_description,
	//      new_description,
	//      old_info,
	//      new_info
	//  )
	//  VALUES (
	//      $1,
	//      $2,
	//      $3,
	//      $4,
	//      $5,
	//      $6,
	//      $7,
	//      $8,
	//      $9
	//  )
	InsertVideoRevision(ctx context.Context, arg *InsertVideoRevisionParams) error
	//InsertYtdlpLog
	//
	//  INSERT INTO ytdlp_logs (job_id, stream, message)
	//  VALUES ($1, $2, $3)
	InsertYtdlpLog(ctx context.Context, arg *InsertYtdlpLogParams) error
	// InvalidateUserSessions marks all sessions for a user as invalid.
	// Any session created before this timestamp will be rejected.
	//
	//  UPDATE users
	//  SET sessions_invalidated_at = NOW(),
	//      updated_at = NOW()
	//  WHERE id = $1 AND deleted_at IS NULL
	InvalidateUserSessions(ctx context.Context, id pgtype.UUID) error
	// LinkDownloadJobVideo stores the created video id.
	//
	//  UPDATE download_jobs
	//  SET video_id = $1,
	//      updated_at = NOW()
	//  WHERE id = $2
	LinkDownloadJobVideo(ctx context.Context, arg *LinkDownloadJobVideoParams) error
	// Get active exports for a list of clip IDs (for clip bank hydration)
	// Only show processing/queued exports that are actively being worked on (updated in last 5 min)
	//
	//  SELECT id, clip_id, status, progress_pct, file_path
	//  FROM clip_exports
	//  WHERE clip_id = ANY($1::uuid[])
	//    AND (
	//      (status IN ('queued', 'processing') AND updated_at > NOW() - INTERVAL '5 minutes')
	//      OR status = 'ready'
	//    )
	//  ORDER BY clip_id, created_at DESC
	ListActiveExportsForClips(ctx context.Context, clipIds []pgtype.UUID) ([]*ListActiveExportsForClipsRow, error)
	// ListAllUsers lists all users in the database
	//
	//  SELECT id, user_name, password, email, email_verified, verify_hash, enabled, role, created_at, updated_at, deleted_at, sessions_invalidated_at FROM users WHERE deleted_at IS NULL
	ListAllUsers(ctx context.Context) ([]*User, error)
	// Get file paths for exports by status (for cleanup before delete)
	//
	//  SELECT id, file_path FROM clip_exports
	//  WHERE status = $1 AND file_path != ''
	ListClipExportFilesByStatus(ctx context.Context, status ExportStatus) ([]*ListClipExportFilesByStatusRow, error)
	// List exports with clip/video info for admin management
	//
	//  SELECT
	//      ce.id,
	//      ce.clip_id,
	//      c.video_id,
	//      ce.status,
	//      ce.variant,
	//      ce.file_path,
	//      ce.size_bytes,
	//      ce.progress_pct,
	//      ce.attempts,
	//      ce.last_error,
	//      ce.created_at,
	//      ce.updated_at,
	//      c.title AS clip_label,
	//      c.duration AS clip_duration,
	//      v.title AS video_title
	//  FROM clip_exports ce
	//  JOIN clips c ON c.id = ce.clip_id
	//  JOIN videos v ON v.id = c.video_id
	//  ORDER BY ce.created_at DESC
	//  LIMIT $2 OFFSET $1
	ListClipExportsForAdmin(ctx context.Context, arg *ListClipExportsForAdminParams) ([]*ListClipExportsForAdminRow, error)
	//ListClipsByVideo
	//
	//  SELECT id, video_id, start_ts, end_ts, duration, created_at, updated_at, created_by, title, description, color, tags, crops, filter_stack FROM clips
	//  WHERE video_id = $1
	//  ORDER BY start_ts ASC
	ListClipsByVideo(ctx context.Context, videoID pgtype.UUID) ([]*Clip, error)
	// ListDistinctTags returns unique tags for filter dropdown
	//
	//  SELECT DISTINCT unnest(tags) AS tag
	//  FROM videos
	//  WHERE tags IS NOT NULL AND array_length(tags, 1) > 0
	//  ORDER BY tag ASC
	//  LIMIT 200
	ListDistinctTags(ctx context.Context) ([]interface{}, error)
	// ListDistinctUploaders returns unique uploader names for filter dropdown
	//
	//  SELECT DISTINCT uploader
	//  FROM videos
	//  WHERE uploader IS NOT NULL AND uploader != ''
	//  ORDER BY uploader ASC
	//  LIMIT 100
	ListDistinctUploaders(ctx context.Context) ([]string, error)
	// ListDownloadJobsByUser returns all download jobs for a user
	//
	//  SELECT id, created_at, updated_at, url, archived_by, status, attempts, last_error, started_at, finished_at, spool_dir, info_json_path, video_id, refresh, process_pid, archived, extra_args
	//  FROM download_jobs
	//  WHERE archived_by = $1
	//    AND archived = FALSE
	//  ORDER BY created_at DESC
	//  LIMIT $2
	ListDownloadJobsByUser(ctx context.Context, arg *ListDownloadJobsByUserParams) ([]*DownloadJob, error)
	// ListDownloadJobsByVideoID returns all download jobs for a video.
	// Matches by video_id FK or by URL matching the video's src column.
	//
	//  SELECT id, created_at, updated_at, url, archived_by, status, attempts, last_error, started_at, finished_at, spool_dir, info_json_path, video_id, refresh, process_pid, archived, extra_args
	//  FROM download_jobs
	//  WHERE video_id = $1
	//     OR url = $2
	//  ORDER BY created_at DESC
	ListDownloadJobsByVideoID(ctx context.Context, arg *ListDownloadJobsByVideoIDParams) ([]*DownloadJob, error)
	// ListIngestJobsByDownloadJobIDs returns ingest jobs for a set of download job IDs.
	//
	//  SELECT id, created_at, updated_at, download_job_id, status, attempts, last_error, started_at, finished_at, asset_scope
	//  FROM ingest_jobs
	//  WHERE download_job_id = ANY($1::uuid[])
	//  ORDER BY created_at DESC
	ListIngestJobsByDownloadJobIDs(ctx context.Context, downloadJobIds []pgtype.UUID) ([]*IngestJob, error)
	//ListMarkersByVideo
	//
	//  SELECT id, video_id, timestamp, title, description, color, marker_type, duration, created_at, created_by FROM markers
	//  WHERE video_id = $1
	//  ORDER BY timestamp ASC
	ListMarkersByVideo(ctx context.Context, videoID pgtype.UUID) ([]*Marker, error)
	//ListOldestClipExportsForCleanup
	//
	//  SELECT id, file_path, size_bytes FROM clip_exports
	//  WHERE status = 'ready'
	//  ORDER BY last_accessed_at ASC NULLS FIRST
	ListOldestClipExportsForCleanup(ctx context.Context) ([]*ListOldestClipExportsForCleanupRow, error)
	//ListPlayerScenePresetsByProducer
	//
	//  SELECT id, producer_id, name, scene, created_at, updated_at FROM player_scene_presets
	//  WHERE producer_id = $1
	//  ORDER BY updated_at DESC
	ListPlayerScenePresetsByProducer(ctx context.Context, producerID pgtype.UUID) ([]*PlayerScenePreset, error)
	// ListRecentDownloadJobs returns recent download jobs for all users
	//
	//  SELECT id, created_at, updated_at, url, archived_by, status, attempts, last_error, started_at, finished_at, spool_dir, info_json_path, video_id, refresh, process_pid, archived, extra_args
	//  FROM download_jobs
	//  WHERE archived = FALSE
	//  ORDER BY created_at DESC
	//  LIMIT 100
	ListRecentDownloadJobs(ctx context.Context) ([]*DownloadJob, error)
	// ListRecentVideos returns recent videos
	//
	//  SELECT id, created_at, updated_at, src, archived_by, title, info, comments, video_path, thumbnail_path, description, tags, uploader, uploader_id, channel_id, upload_date, duration_seconds, view_count, like_count, thumb_gradient_start, thumb_gradient_end, thumb_gradient_angle, file_hash, file_size, assets_status, search, probe_data
	//  FROM videos
	//  ORDER BY created_at DESC
	//  LIMIT 10
	ListRecentVideos(ctx context.Context) ([]*Video, error)
	//ListSessionsByProducer
	//
	//  SELECT id, session_code, producer_id, current_video_id, state, created_at, expires_at, last_activity FROM player_sessions
	//  WHERE producer_id = $1
	//  ORDER BY created_at DESC
	ListSessionsByProducer(ctx context.Context, producerID pgtype.UUID) ([]*PlayerSession, error)
	// ListVideoCommentReplies returns replies (children) for a given parent comment.
	//
	//  SELECT id, video_id, source, comment_id, parent_id, author, author_id, author_url,
	//         published_at, like_count, text, created_at
	//  FROM video_comments
	//  WHERE video_id = $1
	//    AND parent_id = $2::text
	//  ORDER BY published_at ASC NULLS LAST
	//  LIMIT 50
	ListVideoCommentReplies(ctx context.Context, arg *ListVideoCommentRepliesParams) ([]*ListVideoCommentRepliesRow, error)
	// ListVideoComments returns paginated top-level comments for a video.
	// Top-level = parent_id IS NULL or parent_id = 'root'.
	// Ordered by like_count DESC, then published_at DESC.
	//
	//  SELECT id, video_id, source, comment_id, parent_id, author, author_id, author_url,
	//         published_at, like_count, text, created_at
	//  FROM video_comments
	//  WHERE video_id = $1
	//    AND (parent_id IS NULL OR parent_id = 'root')
	//  ORDER BY COALESCE(like_count, 0) DESC, published_at DESC NULLS LAST
	//  LIMIT $3::int
	//  OFFSET $2::int
	ListVideoComments(ctx context.Context, arg *ListVideoCommentsParams) ([]*ListVideoCommentsRow, error)
	// ListVideosForAssetCatchup returns videos that are missing one or more generated assets.
	// Videos with recent errors are backed off exponentially based on _error_count.
	//
	//  SELECT id::text, video_path, thumbnail_path, file_hash, duration_seconds, assets_status
	//  FROM videos
	//  WHERE video_path IS NOT NULL AND btrim(video_path) <> ''
	//  AND (
	//      assets_status = '{}'::jsonb
	//      OR NOT (assets_status ?& array['thumbnail','preview','waveform','file_hash','seek'])
	//      OR assets_status @> '{"thumbnail": false}'::jsonb
	//      OR assets_status @> '{"preview": false}'::jsonb
	//      OR assets_status @> '{"waveform": false}'::jsonb
	//      OR assets_status @> '{"file_hash": false}'::jsonb
	//      OR assets_status @> '{"seek": false}'::jsonb
	//  )
	//  AND (
	//      -- No errors yet, or backoff period has elapsed.
	//      -- Backoff: 2^error_count minutes (1=2m, 2=4m, 3=8m, ... 10+=~17h cap).
	//      NOT (assets_status ? '_error_count')
	//      OR (assets_status->>'_error_count')::int < 1
	//      OR (
	//          assets_status ? '_last_error_at'
	//          AND (assets_status->>'_last_error_at')::timestamptz
	//              + (LEAST(POWER(2, LEAST((assets_status->>'_error_count')::int, 10)), 1024) || ' minutes')::interval
	//              < NOW()
	//      )
	//  )
	//  ORDER BY updated_at ASC
	//  LIMIT $1
	ListVideosForAssetCatchup(ctx context.Context, limit int32) ([]*ListVideosForAssetCatchupRow, error)
	// ListVideosNeedingProbe returns videos with a video_path but no probe_data, for backfill.
	//
	//  SELECT id, video_path
	//  FROM videos
	//  WHERE video_path IS NOT NULL AND btrim(video_path) <> ''
	//    AND probe_data IS NULL
	//  ORDER BY created_at DESC
	//  LIMIT $1
	ListVideosNeedingProbe(ctx context.Context, maxCount int32) ([]*ListVideosNeedingProbeRow, error)
	// ListVideosPaginated returns videos with filters, sorting, and pagination.
	// Returns total_count via window function for pagination UI.
	//
	//  SELECT
	//      v.id, v.created_at, v.updated_at, v.src, v.archived_by, v.title, v.info, v.comments, v.video_path, v.thumbnail_path, v.description, v.tags, v.uploader, v.uploader_id, v.channel_id, v.upload_date, v.duration_seconds, v.view_count, v.like_count, v.thumb_gradient_start, v.thumb_gradient_end, v.thumb_gradient_angle, v.file_hash, v.file_size, v.assets_status, v.search, v.probe_data,
	//      COUNT(*) OVER() AS total_count,
	//      COALESCE((SELECT COUNT(*) FROM clips c WHERE c.video_id = v.id), 0) AS clip_count,
	//      COALESCE((SELECT COUNT(*) FROM markers m WHERE m.video_id = v.id), 0) AS marker_count,
	//      COALESCE((SELECT MAX(c.created_at) FROM clips c WHERE c.video_id = v.id), '1970-01-01'::timestamptz) AS last_clip_at,
	//      COALESCE((SELECT MAX(m.created_at) FROM markers m WHERE m.video_id = v.id), '1970-01-01'::timestamptz) AS last_marker_at,
	//      COALESCE(u.user_name, 'unknown') AS archived_by_username
	//  FROM videos v
	//  LEFT JOIN users u ON v.archived_by = u.id
	//  WHERE
	//      -- Full-text search (optional)
	//      ($1::text IS NULL OR v.search @@ plainto_tsquery('simple', $1))
	//      -- Uploader filter (optional)
	//      AND ($2::text IS NULL OR v.uploader = $2)
	//      -- Channel filter (optional)
	//      AND ($3::text IS NULL OR v.channel_id = $3)
	//      -- Duration filter: short=<5min, medium=5-30min, long=>30min
	//      AND (
	//          $4::text IS NULL
	//          OR ($4 = 'short' AND v.duration_seconds < 300)
	//          OR ($4 = 'medium' AND v.duration_seconds >= 300 AND v.duration_seconds < 1800)
	//          OR ($4 = 'long' AND v.duration_seconds >= 1800)
	//      )
	//      -- Tags filter (any tag matches)
	//      AND ($5::text[] IS NULL OR v.tags && $5::text[])
	//      -- Date range (archived or published based on date_type)
	//      AND (
	//          $6::date IS NULL
	//          OR ($7::text = 'published' AND v.upload_date >= $6)
	//          OR ($7::text IS DISTINCT FROM 'published' AND v.created_at::date >= $6)
	//      )
	//      AND (
	//          $8::date IS NULL
	//          OR ($7::text = 'published' AND v.upload_date <= $8)
	//          OR ($7::text IS DISTINCT FROM 'published' AND v.created_at::date <= $8)
	//      )
	//      -- Has clips filter
	//      AND ($9::boolean IS NULL OR $9 = FALSE
	//           OR EXISTS (SELECT 1 FROM clips c WHERE c.video_id = v.id))
	//      -- Has markers filter
	//      AND ($10::boolean IS NULL OR $10 = FALSE
	//           OR EXISTS (SELECT 1 FROM markers m WHERE m.video_id = v.id))
	//  ORDER BY
	//      -- Date sorts (archived)
	//      CASE WHEN $11 = 'newest' THEN v.created_at END DESC NULLS LAST,
	//      CASE WHEN $11 = 'oldest' THEN v.created_at END ASC NULLS LAST,
	//      -- Date sorts (published)
	//      CASE WHEN $11 = 'published-newest' THEN v.upload_date END DESC NULLS LAST,
	//      CASE WHEN $11 = 'published-oldest' THEN v.upload_date END ASC NULLS LAST,
	//      -- Title sorts
	//      CASE WHEN $11 = 'alpha' THEN v.title END ASC NULLS LAST,
	//      CASE WHEN $11 = 'alpha-desc' THEN v.title END DESC NULLS LAST,
	//      -- Duration sorts
	//      CASE WHEN $11 = 'duration' THEN v.duration_seconds END ASC NULLS LAST,
	//      CASE WHEN $11 = 'duration-desc' THEN v.duration_seconds END DESC NULLS LAST,
	//      -- Activity sorts
	//      CASE WHEN $11 = 'most-clips' THEN (SELECT COUNT(*) FROM clips c WHERE c.video_id = v.id) END DESC NULLS LAST,
	//      CASE WHEN $11 = 'most-markers' THEN (SELECT COUNT(*) FROM markers m WHERE m.video_id = v.id) END DESC NULLS LAST,
	//      CASE WHEN $11 = 'recently-clipped' THEN (SELECT MAX(c.created_at) FROM clips c WHERE c.video_id = v.id) END DESC NULLS LAST,
	//      CASE WHEN $11 = 'recently-marked' THEN (SELECT MAX(m.created_at) FROM markers m WHERE m.video_id = v.id) END DESC NULLS LAST,
	//      -- Default fallback
	//      v.created_at DESC
	//  LIMIT $13
	//  OFFSET $12
	ListVideosPaginated(ctx context.Context, arg *ListVideosPaginatedParams) ([]*ListVideosPaginatedRow, error)
	// ListVideosWithAssetErrors returns videos that have recorded asset generation errors.
	//
	//  SELECT id::text, title, video_path, assets_status, updated_at
	//  FROM videos
	//  WHERE video_path IS NOT NULL AND btrim(video_path) <> ''
	//  AND assets_status ? '_error_count'
	//  AND (assets_status->>'_error_count')::int > 0
	//  ORDER BY (assets_status->>'_last_error_at')::timestamptz DESC NULLS LAST
	//  LIMIT $1
	ListVideosWithAssetErrors(ctx context.Context, limit int32) ([]*ListVideosWithAssetErrorsRow, error)
	// Listen for download job notifications.
	//
	//  LISTEN download_jobs
	ListenDownloadJobs(ctx context.Context) error
	// Listen for ingest job notifications.
	//
	//  LISTEN ingest_jobs
	ListenIngestJobs(ctx context.Context) error
	// MarkDownloadJobFailed stores error and marks job failed.
	//
	//  UPDATE download_jobs
	//  SET status = 'failed',
	//      finished_at = NOW(),
	//      updated_at = NOW(),
	//      last_error = $1
	//  WHERE id = $2
	MarkDownloadJobFailed(ctx context.Context, arg *MarkDownloadJobFailedParams) error
	// MarkDownloadJobSucceeded stores paths and marks job done.
	//
	//  UPDATE download_jobs
	//  SET status = 'succeeded',
	//      finished_at = NOW(),
	//      updated_at = NOW(),
	//      spool_dir = $1,
	//      info_json_path = $2,
	//      last_error = NULL
	//  WHERE id = $3
	MarkDownloadJobSucceeded(ctx context.Context, arg *MarkDownloadJobSucceededParams) error
	// MarkIngestJobFailed marks ingest failed.
	//
	//  UPDATE ingest_jobs
	//  SET status = 'failed',
	//      finished_at = NOW(),
	//      updated_at = NOW(),
	//      last_error = $1
	//  WHERE id = $2
	MarkIngestJobFailed(ctx context.Context, arg *MarkIngestJobFailedParams) error
	// MarkIngestJobSucceeded marks ingest done.
	//
	//  UPDATE ingest_jobs
	//  SET status = 'succeeded',
	//      finished_at = NOW(),
	//      updated_at = NOW(),
	//      last_error = NULL
	//  WHERE id = $1
	MarkIngestJobSucceeded(ctx context.Context, id pgtype.UUID) error
	// RecoverStuckDownloadJobs resets orphaned "processing" jobs back to "queued" on service startup.
	// Jobs stuck in "processing" for more than the timeout are assumed to have been orphaned by a crash or restart.
	//
	//  UPDATE download_jobs
	//  SET status = 'queued',
	//      updated_at = NOW()
	//  WHERE status = 'processing'
	//    AND updated_at < NOW() - INTERVAL '5 minutes'
	RecoverStuckDownloadJobs(ctx context.Context) error
	// RecoverStuckIngestJobs resets orphaned "processing" jobs back to "queued" on service startup.
	// Jobs stuck in "processing" for more than the timeout are assumed to have been orphaned by a crash.
	//
	//  UPDATE ingest_jobs
	//  SET status = 'queued',
	//      updated_at = NOW()
	//  WHERE status = 'processing'
	//    AND updated_at < NOW() - INTERVAL '5 minutes'
	RecoverStuckIngestJobs(ctx context.Context) error
	// Requeue all failed exports
	//
	//  UPDATE clip_exports
	//  SET status = 'queued',
	//      locked_at = NULL,
	//      locked_by = NULL,
	//      pid = NULL,
	//      progress_pct = 0,
	//      attempts = 0,
	//      last_error = NULL,
	//      updated_at = NOW()
	//  WHERE status = 'error'
	RequeueAllErrorExports(ctx context.Context) error
	// Re-queue an export that was marked ready but file is missing
	//
	//  UPDATE clip_exports
	//  SET status = 'queued',
	//      file_path = '',
	//      size_bytes = 0,
	//      locked_at = NULL,
	//      locked_by = NULL,
	//      progress_pct = 0,
	//      started_at = NULL,
	//      finished_at = NULL,
	//      last_error = 'Requeued: output file was missing',
	//      updated_at = NOW()
	//  WHERE id = $1
	RequeueClipExport(ctx context.Context, id pgtype.UUID) error
	// Reset stuck exports that have been in processing state too long without updates
	//
	//  UPDATE clip_exports
	//  SET status = 'queued',
	//      locked_at = NULL,
	//      locked_by = NULL,
	//      progress_pct = 0,
	//      updated_at = NOW()
	//  WHERE status = 'processing'
	//    AND updated_at < NOW() - INTERVAL '5 minutes'
	ResetStuckExports(ctx context.Context) error
	//ResetUserKeybindings
	//
	//  DELETE FROM user_keybindings
	//  WHERE user_id = $1
	ResetUserKeybindings(ctx context.Context, userID pgtype.UUID) error
	// RetryDownloadJob resets a job to queued status for retry.
	//
	//  UPDATE download_jobs
	//  SET status = 'queued',
	//      last_error = NULL,
	//      started_at = NULL,
	//      finished_at = NULL,
	//      process_pid = NULL,
	//      updated_at = NOW()
	//  WHERE id = $1
	RetryDownloadJob(ctx context.Context, id pgtype.UUID) error
	//RevokeAllUserExtensionTokens
	//
	//  UPDATE extension_tokens
	//  SET revoked = TRUE
	//  WHERE user_id = $1
	RevokeAllUserExtensionTokens(ctx context.Context, userID pgtype.UUID) error
	//RevokeExtensionToken
	//
	//  UPDATE extension_tokens
	//  SET revoked = TRUE
	//  WHERE token = $1
	RevokeExtensionToken(ctx context.Context, token string) error
	// SearchVideoComments returns comments matching a text search query.
	//
	//  SELECT id, video_id, source, comment_id, parent_id, author, author_id, author_url,
	//         published_at, like_count, text, created_at
	//  FROM video_comments
	//  WHERE video_id = $1
	//    AND search @@ plainto_tsquery('simple', $2::text)
	//  ORDER BY COALESCE(like_count, 0) DESC
	//  LIMIT $4::int
	//  OFFSET $3::int
	SearchVideoComments(ctx context.Context, arg *SearchVideoCommentsParams) ([]*SearchVideoCommentsRow, error)
	// SearchVideos searches title/description/tags + comments + transcript.
	//
	//  WITH q AS (
	//    SELECT plainto_tsquery('simple', $3) AS tsq
	//  ),
	//  video_hits AS (
	//    SELECT v.id AS video_id, ts_rank_cd(v.search, q.tsq) AS rank
	//    FROM videos v, q
	//    WHERE v.search @@ q.tsq
	//  ),
	//  comment_hits AS (
	//    SELECT vc.video_id AS video_id, max(ts_rank_cd(vc.search, q.tsq)) AS rank
	//    FROM video_comments vc, q
	//    JOIN videos v ON v.id = vc.video_id
	//    WHERE vc.search @@ q.tsq
	//    GROUP BY vc.video_id
	//  ),
	//  transcript_hits AS (
	//    SELECT vt.video_id AS video_id, max(ts_rank_cd(vt.search, q.tsq)) AS rank
	//    FROM video_transcripts vt, q
	//    JOIN videos v ON v.id = vt.video_id
	//    WHERE vt.search @@ q.tsq
	//    GROUP BY vt.video_id
	//  ),
	//  hits AS (
	//    SELECT video_id, rank FROM video_hits
	//    UNION ALL
	//    SELECT video_id, rank FROM comment_hits
	//    UNION ALL
	//    SELECT video_id, rank FROM transcript_hits
	//  ),
	//  ranked AS (
	//    SELECT video_id, sum(rank) AS rank
	//    FROM hits
	//    GROUP BY video_id
	//  )
	//  SELECT v.id, v.created_at, v.updated_at, v.src, v.archived_by, v.title, v.info, v.comments, v.video_path, v.thumbnail_path, v.description, v.tags, v.uploader, v.uploader_id, v.channel_id, v.upload_date, v.duration_seconds, v.view_count, v.like_count, v.thumb_gradient_start, v.thumb_gradient_end, v.thumb_gradient_angle, v.file_hash, v.file_size, v.assets_status, v.search, v.probe_data
	//  FROM ranked r
	//  JOIN videos v ON v.id = r.video_id
	//  ORDER BY r.rank DESC, v.created_at DESC
	//  LIMIT $2
	//  OFFSET $1
	SearchVideos(ctx context.Context, arg *SearchVideosParams) ([]*Video, error)
	// SelectUserByEmail selects a user by email from the database
	//
	//  SELECT id, user_name, password, email, email_verified, verify_hash, enabled, role, created_at, updated_at, deleted_at, sessions_invalidated_at FROM users WHERE email = $1 AND deleted_at IS NULL
	SelectUserByEmail(ctx context.Context, email string) (*User, error)
	// SelectUserByID selects a user by ID from the database
	//
	//  SELECT id, user_name, password, email, email_verified, verify_hash, enabled, role, created_at, updated_at, deleted_at, sessions_invalidated_at FROM users WHERE id = $1 AND deleted_at IS NULL
	SelectUserByID(ctx context.Context, id pgtype.UUID) (*User, error)
	// SelectUserByUserName selects a user by user name from the database
	//
	//  SELECT id, user_name, password, email, email_verified, verify_hash, enabled, role, created_at, updated_at, deleted_at, sessions_invalidated_at FROM users WHERE user_name = $1 AND deleted_at IS NULL
	SelectUserByUserName(ctx context.Context, userName string) (*User, error)
	// SelectVideoBySrc returns a video by src.
	//
	//  SELECT id, created_at, updated_at, src, archived_by, title, info, comments, video_path, thumbnail_path, description, tags, uploader, uploader_id, channel_id, upload_date, duration_seconds, view_count, like_count, thumb_gradient_start, thumb_gradient_end, thumb_gradient_angle, file_hash, file_size, assets_status, search, probe_data
	//  FROM videos
	//  WHERE src = $1
	SelectVideoBySrc(ctx context.Context, src string) (*Video, error)
	// SetUserEnabled updates a user's enabled flag
	//
	//  UPDATE users
	//  SET enabled = $1,
	//      updated_at = NOW()
	//  WHERE id = $2 AND deleted_at IS NULL
	SetUserEnabled(ctx context.Context, arg *SetUserEnabledParams) error
	// SetUserRole updates a user's role
	//
	//  UPDATE users
	//  SET role = $1,
	//      updated_at = NOW()
	//  WHERE id = $2 AND deleted_at IS NULL
	SetUserRole(ctx context.Context, arg *SetUserRoleParams) error
	// Attempts to acquire a PostgreSQL advisory lock (non-blocking)
	// Returns true if the lock was acquired, false if it's already held
	//
	//  SELECT pg_try_advisory_lock($1::bigint) AS acquired
	TryAdvisoryLock(ctx context.Context, lockID int64) (bool, error)
	// UnarchiveJob unmarks a job from archived status.
	//
	//  UPDATE download_jobs
	//  SET archived = FALSE,
	//      updated_at = NOW()
	//  WHERE id = $1
	UnarchiveJob(ctx context.Context, id pgtype.UUID) error
	// Release lock without changing status (for graceful shutdown)
	//
	//  UPDATE clip_exports
	//  SET locked_at = NULL,
	//      locked_by = NULL,
	//      pid = NULL,
	//      updated_at = NOW()
	//  WHERE id = $1
	UnlockClipExport(ctx context.Context, id pgtype.UUID) error
	//UpdateClip
	//
	//  UPDATE clips
	//  SET
	//      start_ts = COALESCE($1, start_ts),
	//      end_ts = COALESCE($2, end_ts),
	//      duration = COALESCE($3, duration),
	//      title = COALESCE($4, title),
	//      description = COALESCE($5, description),
	//      color = COALESCE($6, color),
	//      tags = COALESCE($7, tags),
	//      filter_stack = COALESCE($8, filter_stack),
	//      updated_at = NOW()
	//  WHERE id = $9
	//  RETURNING id, video_id, start_ts, end_ts, duration, created_at, updated_at, created_by, title, description, color, tags, crops, filter_stack
	UpdateClip(ctx context.Context, arg *UpdateClipParams) (*Clip, error)
	//UpdateClipCrops
	//
	//  UPDATE clips
	//  SET crops = $1,
	//      updated_at = NOW()
	//  WHERE id = $2
	UpdateClipCrops(ctx context.Context, arg *UpdateClipCropsParams) error
	//UpdateClipExportFilePath
	//
	//  UPDATE clip_exports
	//  SET file_path = $1, updated_at = NOW()
	//  WHERE id = $2
	UpdateClipExportFilePath(ctx context.Context, arg *UpdateClipExportFilePathParams) error
	//UpdateClipExportLastAccessed
	//
	//  UPDATE clip_exports
	//  SET last_accessed_at = NOW(), updated_at = NOW()
	//  WHERE id = $1
	UpdateClipExportLastAccessed(ctx context.Context, id pgtype.UUID) error
	// Store the ffmpeg process PID for potential cleanup
	//
	//  UPDATE clip_exports
	//  SET pid = $1,
	//      updated_at = NOW()
	//  WHERE id = $2
	UpdateClipExportPID(ctx context.Context, arg *UpdateClipExportPIDParams) error
	// Update progress percentage during encoding
	//
	//  UPDATE clip_exports
	//  SET progress_pct = $1,
	//      updated_at = NOW()
	//  WHERE id = $2
	UpdateClipExportProgress(ctx context.Context, arg *UpdateClipExportProgressParams) error
	//UpdateClipFilterStack
	//
	//  UPDATE clips
	//  SET filter_stack = $1,
	//      updated_at = NOW()
	//  WHERE id = $2
	UpdateClipFilterStack(ctx context.Context, arg *UpdateClipFilterStackParams) error
	// UpdateDownloadJobPID stores the process ID of the running download.
	//
	//  UPDATE download_jobs
	//  SET process_pid = $1,
	//      updated_at = NOW()
	//  WHERE id = $2
	UpdateDownloadJobPID(ctx context.Context, arg *UpdateDownloadJobPIDParams) error
	//UpdateExtensionTokenLastUsed
	//
	//  UPDATE extension_tokens
	//  SET last_used_at = NOW()
	//  WHERE token = $1
	UpdateExtensionTokenLastUsed(ctx context.Context, token string) error
	//UpdateMarker
	//
	//  UPDATE markers
	//  SET
	//      timestamp = COALESCE($1, timestamp),
	//      title = COALESCE($2, title),
	//      description = COALESCE($3, description),
	//      color = COALESCE($4, color),
	//      marker_type = COALESCE($5, marker_type),
	//      duration = COALESCE($6, duration)
	//  WHERE id = $7
	//  RETURNING id, video_id, timestamp, title, description, color, marker_type, duration, created_at, created_by
	UpdateMarker(ctx context.Context, arg *UpdateMarkerParams) (*Marker, error)
	//UpdatePlayerSessionActivity
	//
	//  UPDATE player_sessions
	//  SET last_activity = NOW()
	//  WHERE id = $1
	UpdatePlayerSessionActivity(ctx context.Context, id pgtype.UUID) error
	//UpdatePlayerSessionState
	//
	//  UPDATE player_sessions
	//  SET state = $1, last_activity = NOW()
	//  WHERE id = $2
	UpdatePlayerSessionState(ctx context.Context, arg *UpdatePlayerSessionStateParams) error
	//UpdatePlayerSessionVideo
	//
	//  UPDATE player_sessions
	//  SET current_video_id = $1, last_activity = NOW()
	//  WHERE id = $2
	UpdatePlayerSessionVideo(ctx context.Context, arg *UpdatePlayerSessionVideoParams) error
	// UpdateUser updates a user in the database
	//
	//  UPDATE users
	//  SET email = $1,
	//      password = $2,
	//      user_name = $3,
	//      updated_at = NOW(),
	//      email_verified = $4
	//  WHERE id = $5 AND deleted_at IS NULL
	UpdateUser(ctx context.Context, arg *UpdateUserParams) error
	// UpdateVideoAssetsStatus merges asset status flags into videos.assets_status.
	//
	//  UPDATE videos
	//  SET assets_status = COALESCE(assets_status, '{}'::jsonb) || $1::asset_status_map,
	//      updated_at = NOW()
	//  WHERE id = $2
	UpdateVideoAssetsStatus(ctx context.Context, arg *UpdateVideoAssetsStatusParams) error
	// UpdateVideoFileHashAndSize updates file_hash + file_size for a video.
	//
	//  UPDATE videos
	//  SET file_hash = $1,
	//      file_size = $2,
	//      updated_at = NOW()
	//  WHERE id = $3
	UpdateVideoFileHashAndSize(ctx context.Context, arg *UpdateVideoFileHashAndSizeParams) error
	// UpdateVideoPath updates the video_path for a video.
	//
	//  UPDATE videos
	//  SET video_path = $1,
	//      updated_at = NOW()
	//  WHERE id = $2
	UpdateVideoPath(ctx context.Context, arg *UpdateVideoPathParams) error
	// UpdateVideoProbeData stores ffprobe data for a video.
	//
	//  UPDATE videos
	//  SET probe_data = $1,
	//      updated_at = NOW()
	//  WHERE id = $2
	UpdateVideoProbeData(ctx context.Context, arg *UpdateVideoProbeDataParams) error
	// UpdateVideoThumbnailPath updates the thumbnail_path for a video.
	//
	//  UPDATE videos
	//  SET thumbnail_path = $1,
	//      updated_at = NOW()
	//  WHERE id = $2
	UpdateVideoThumbnailPath(ctx context.Context, arg *UpdateVideoThumbnailPathParams) error
	// UpsertAdminEmails sets admin emails (creates row if missing)
	//
	//  INSERT INTO instance_settings (id, registration_enabled, admin_emails, updated_at)
	//  VALUES (1, TRUE, $1, NOW())
	//  ON CONFLICT (id) DO UPDATE
	//  SET admin_emails = EXCLUDED.admin_emails,
	//      updated_at = NOW()
	UpsertAdminEmails(ctx context.Context, adminEmails []string) error
	// UpsertClipExportStorageLimit sets clip export storage limit (creates row if missing)
	//
	//  INSERT INTO instance_settings (id, registration_enabled, admin_emails, clip_export_storage_limit_bytes, updated_at)
	//  VALUES (1, TRUE, ARRAY[]::text[], $1, NOW())
	//  ON CONFLICT (id) DO UPDATE
	//  SET clip_export_storage_limit_bytes = EXCLUDED.clip_export_storage_limit_bytes,
	//      updated_at = NOW()
	UpsertClipExportStorageLimit(ctx context.Context, limitBytes int64) error
	// UpsertPlaybackPosition saves or updates the playback position for a user/video
	//
	//  INSERT INTO playback_positions (user_id, video_id, position_seconds, updated_at)
	//  VALUES ($1, $2, $3, CURRENT_TIMESTAMP)
	//  ON CONFLICT (user_id, video_id)
	//  DO UPDATE SET
	//      position_seconds = EXCLUDED.position_seconds,
	//      updated_at = CURRENT_TIMESTAMP
	UpsertPlaybackPosition(ctx context.Context, arg *UpsertPlaybackPositionParams) error
	//UpsertPlayerScenePreset
	//
	//  INSERT INTO player_scene_presets (producer_id, name, scene)
	//  VALUES ($1, $2, $3)
	//  ON CONFLICT (producer_id, name)
	//  DO UPDATE SET scene = EXCLUDED.scene, updated_at = NOW()
	//  RETURNING id, producer_id, name, scene, created_at, updated_at
	UpsertPlayerScenePreset(ctx context.Context, arg *UpsertPlayerScenePresetParams) (*PlayerScenePreset, error)
	// UpsertRegistrationEnabled sets registration_enabled (creates row if missing)
	//
	//  INSERT INTO instance_settings (id, registration_enabled, admin_emails, updated_at)
	//  VALUES (1, $1, $2, NOW())
	//  ON CONFLICT (id) DO UPDATE
	//  SET registration_enabled = EXCLUDED.registration_enabled,
	//      admin_emails = EXCLUDED.admin_emails,
	//      updated_at = NOW()
	UpsertRegistrationEnabled(ctx context.Context, arg *UpsertRegistrationEnabledParams) error
	//UpsertUserKeybinding
	//
	//  INSERT INTO user_keybindings (user_id, action, key)
	//  VALUES ($1, $2, $3)
	//  ON CONFLICT (user_id, action)
	//  DO UPDATE SET key = EXCLUDED.key
	UpsertUserKeybinding(ctx context.Context, arg *UpsertUserKeybindingParams) error
	// UpsertVideoCommentsFromJSON ingests a JSON array of yt-dlp comment objects.
	// It extracts common fields for indexing/search and stores the full raw object.
	//
	// Required JSON shape: a JSON array of objects. Elements without an id are skipped.
	//
	//  INSERT INTO video_comments (
	//      video_id,
	//      source,
	//      comment_id,
	//      parent_id,
	//      author,
	//      author_id,
	//      author_url,
	//      published_at,
	//      like_count,
	//      text,
	//      search,
	//      raw,
	//      updated_at
	//  )
	//  SELECT
	//      $1::uuid AS video_id,
	//      $2::text AS source,
	//      c->>'id' AS comment_id,
	//      COALESCE(NULLIF(c->>'parent', ''), NULLIF(c->>'parent_id', '')) AS parent_id,
	//      NULLIF(c->>'author', '') AS author,
	//      NULLIF(c->>'author_id', '') AS author_id,
	//      NULLIF(c->>'author_url', '') AS author_url,
	//      CASE
	//          WHEN (c->>'timestamp') ~ '^[0-9]+(\\.[0-9]+)?$' THEN to_timestamp((c->>'timestamp')::double precision)
	//          ELSE NULL
	//      END AS published_at,
	//      CASE
	//          WHEN (c->>'like_count') ~ '^-?[0-9]+$' THEN (c->>'like_count')::bigint
	//          ELSE NULL
	//      END AS like_count,
	//      COALESCE(NULLIF(c->>'text', ''), NULLIF(c->>'content', ''), NULLIF(c->>'comment', '')) AS text,
	//      to_tsvector('simple'::regconfig,
	//          coalesce(COALESCE(NULLIF(c->>'text', ''), NULLIF(c->>'content', ''), NULLIF(c->>'comment', '')), '')
	//          || ' ' ||
	//          coalesce(NULLIF(c->>'author', ''), '')
	//      ) AS search,
	//      c AS raw,
	//      NOW() AS updated_at
	//  FROM jsonb_array_elements($3::jsonb) AS c
	//  WHERE COALESCE(NULLIF(c->>'id', ''), '') <> ''
	//  ON CONFLICT (video_id, source, comment_id)
	//  DO UPDATE SET
	//      parent_id = EXCLUDED.parent_id,
	//      author = EXCLUDED.author,
	//      author_id = EXCLUDED.author_id,
	//      author_url = EXCLUDED.author_url,
	//      published_at = EXCLUDED.published_at,
	//      like_count = EXCLUDED.like_count,
	//      text = EXCLUDED.text,
	//      search = EXCLUDED.search,
	//      raw = EXCLUDED.raw,
	//      updated_at = NOW()
	UpsertVideoCommentsFromJSON(ctx context.Context, arg *UpsertVideoCommentsFromJSONParams) error
	// UpsertVideoTranscript stores (or updates) a transcript for a video+lang.
	//
	//  INSERT INTO video_transcripts (
	//      video_id,
	//      lang,
	//      format,
	//      text,
	//      search,
	//      raw,
	//      updated_at
	//  )
	//  VALUES (
	//      $1,
	//      $2::language_tag,
	//      $3,
	//      $4,
	//      to_tsvector('simple'::regconfig, coalesce($4, '')),
	//      $5,
	//      NOW()
	//  )
	//  ON CONFLICT (video_id, lang)
	//  DO UPDATE SET
	//      format = EXCLUDED.format,
	//      text = EXCLUDED.text,
	//      search = EXCLUDED.search,
	//      raw = EXCLUDED.raw,
	//      updated_at = NOW()
	UpsertVideoTranscript(ctx context.Context, arg *UpsertVideoTranscriptParams) error
	// UsernameTaken checks if a username is already taken
	//
	//  SELECT EXISTS (
	//      SELECT 1
	//      FROM users
	//      WHERE user_name = $1 AND deleted_at IS NULL
	//  )
	UsernameTaken(ctx context.Context, userName string) (bool, error)
	// insertUser inserts a user into the database
	// it is intentionally kept private, user creation should be done via
	// the NewUser helper found in internal/db/user.go
	//
	//  INSERT INTO users (
	//      id,
	//      email,
	//      password,
	//      user_name,
	//      role,
	//      created_at,
	//      updated_at,
	//      deleted_at
	//  )
	//  VALUES (
	//      $1,
	//      $2,
	//      $3,
	//      $4,
	//      $5,
	//      NOW(),
	//      NOW(),
	//      NULL
	//  )
	//  RETURNING id, user_name, password, email, email_verified, verify_hash, enabled, role, created_at, updated_at, deleted_at, sessions_invalidated_at
	insertUser(ctx context.Context, arg *insertUserParams) (*User, error)
}

var _ Querier = (*Queries)(nil)
