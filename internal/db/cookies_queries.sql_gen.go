// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cookies_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"thirdcoast.systems/rewind/pkg/utils/crypto"
)

const countUserCookies = `-- name: CountUserCookies :one
SELECT COUNT(*) as count
FROM cookies
WHERE user_id = $1
`

// CountUserCookies counts the number of cookies for a user
//
//	SELECT COUNT(*) as count
//	FROM cookies
//	WHERE user_id = $1
func (q *Queries) CountUserCookies(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserCookies, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteUserCookies = `-- name: DeleteUserCookies :exec
DELETE FROM cookies
WHERE user_id = $1
`

// DeleteUserCookies deletes all cookies for a user
//
//	DELETE FROM cookies
//	WHERE user_id = $1
func (q *Queries) DeleteUserCookies(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserCookies, userID)
	return err
}

const getUserCookies = `-- name: GetUserCookies :many
SELECT domain, flag, path, secure, expiration, name, value
FROM cookies
WHERE user_id = $1
ORDER BY domain, name, path
`

type GetUserCookiesRow struct {
	Domain     string                 `db:"domain" json:"Domain"`
	Flag       string                 `db:"flag" json:"Flag"`
	Path       string                 `db:"path" json:"Path"`
	Secure     string                 `db:"secure" json:"Secure"`
	Expiration int64                  `db:"expiration" json:"Expiration"`
	Name       string                 `db:"name" json:"Name"`
	Value      crypto.EncryptedString `db:"value" json:"Value"`
}

// GetUserCookies returns all cookies for a user in Netscape format
//
//	SELECT domain, flag, path, secure, expiration, name, value
//	FROM cookies
//	WHERE user_id = $1
//	ORDER BY domain, name, path
func (q *Queries) GetUserCookies(ctx context.Context, userID pgtype.UUID) ([]*GetUserCookiesRow, error) {
	rows, err := q.db.Query(ctx, getUserCookies, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUserCookiesRow
	for rows.Next() {
		var i GetUserCookiesRow
		if err := rows.Scan(
			&i.Domain,
			&i.Flag,
			&i.Path,
			&i.Secure,
			&i.Expiration,
			&i.Name,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCookie = `-- name: InsertCookie :exec
INSERT INTO cookies (user_id, domain, flag, path, secure, expiration, name, value)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
ON CONFLICT (user_id, domain, name, path)
DO UPDATE SET
    flag = EXCLUDED.flag,
    secure = EXCLUDED.secure,
    expiration = EXCLUDED.expiration,
    value = EXCLUDED.value,
    updated_at = NOW()
`

type InsertCookieParams struct {
	UserID     pgtype.UUID            `db:"user_id" json:"UserID"`
	Domain     string                 `db:"domain" json:"Domain"`
	Flag       string                 `db:"flag" json:"Flag"`
	Path       string                 `db:"path" json:"Path"`
	Secure     string                 `db:"secure" json:"Secure"`
	Expiration int64                  `db:"expiration" json:"Expiration"`
	Name       string                 `db:"name" json:"Name"`
	Value      crypto.EncryptedString `db:"value" json:"Value"`
}

// InsertCookie inserts a new cookie for a user
//
//	INSERT INTO cookies (user_id, domain, flag, path, secure, expiration, name, value)
//	VALUES (
//	    $1,
//	    $2,
//	    $3,
//	    $4,
//	    $5,
//	    $6,
//	    $7,
//	    $8
//	)
//	ON CONFLICT (user_id, domain, name, path)
//	DO UPDATE SET
//	    flag = EXCLUDED.flag,
//	    secure = EXCLUDED.secure,
//	    expiration = EXCLUDED.expiration,
//	    value = EXCLUDED.value,
//	    updated_at = NOW()
func (q *Queries) InsertCookie(ctx context.Context, arg *InsertCookieParams) error {
	_, err := q.db.Exec(ctx, insertCookie,
		arg.UserID,
		arg.Domain,
		arg.Flag,
		arg.Path,
		arg.Secure,
		arg.Expiration,
		arg.Name,
		arg.Value,
	)
	return err
}
