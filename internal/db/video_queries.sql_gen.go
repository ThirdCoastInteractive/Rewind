// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: video_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"thirdcoast.systems/rewind/pkg/videoinfo"
)

const clearAllVideoAssetErrors = `-- name: ClearAllVideoAssetErrors :exec
UPDATE videos
SET assets_status = assets_status - '_error_count' - '_last_error_at' - '_errors',
    updated_at = NOW()
WHERE assets_status ? '_error_count'
AND (assets_status->>'_error_count')::int > 0
`

// ClearAllVideoAssetErrors resets error tracking for all videos so catchup retries them.
//
//	UPDATE videos
//	SET assets_status = assets_status - '_error_count' - '_last_error_at' - '_errors',
//	    updated_at = NOW()
//	WHERE assets_status ? '_error_count'
//	AND (assets_status->>'_error_count')::int > 0
func (q *Queries) ClearAllVideoAssetErrors(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearAllVideoAssetErrors)
	return err
}

const clearVideoAssetErrors = `-- name: ClearVideoAssetErrors :exec
UPDATE videos
SET assets_status = assets_status - '_error_count' - '_last_error_at' - '_errors',
    updated_at = NOW()
WHERE id = $1
`

// ClearVideoAssetErrors resets error tracking for a single video so catchup retries it.
//
//	UPDATE videos
//	SET assets_status = assets_status - '_error_count' - '_last_error_at' - '_errors',
//	    updated_at = NOW()
//	WHERE id = $1
func (q *Queries) ClearVideoAssetErrors(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, clearVideoAssetErrors, id)
	return err
}

const clearVideoFromJobs = `-- name: ClearVideoFromJobs :exec
UPDATE download_jobs
SET video_id = NULL,
    updated_at = NOW()
WHERE video_id = $1
`

// ClearVideoFromJobs sets video_id to NULL for all jobs referencing this video.
//
//	UPDATE download_jobs
//	SET video_id = NULL,
//	    updated_at = NOW()
//	WHERE video_id = $1
func (q *Queries) ClearVideoFromJobs(ctx context.Context, videoID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, clearVideoFromJobs, videoID)
	return err
}

const countVideosWithAssetErrors = `-- name: CountVideosWithAssetErrors :one
SELECT COUNT(*)
FROM videos
WHERE video_path IS NOT NULL AND btrim(video_path) <> ''
AND assets_status ? '_error_count'
AND (assets_status->>'_error_count')::int > 0
`

// CountVideosWithAssetErrors returns the number of videos with asset generation errors.
//
//	SELECT COUNT(*)
//	FROM videos
//	WHERE video_path IS NOT NULL AND btrim(video_path) <> ''
//	AND assets_status ? '_error_count'
//	AND (assets_status->>'_error_count')::int > 0
func (q *Queries) CountVideosWithAssetErrors(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countVideosWithAssetErrors)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVideosWithVideoPath = `-- name: CountVideosWithVideoPath :one
SELECT COUNT(*)
FROM videos
WHERE video_path IS NOT NULL AND btrim(video_path) <> ''
`

// CountVideosWithVideoPath returns count of videos that have a video_path.
//
//	SELECT COUNT(*)
//	FROM videos
//	WHERE video_path IS NOT NULL AND btrim(video_path) <> ''
func (q *Queries) CountVideosWithVideoPath(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countVideosWithVideoPath)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteVideo = `-- name: DeleteVideo :exec
DELETE FROM videos
WHERE id = $1
`

// DeleteVideo deletes a video by ID (cascades to related records).
//
//	DELETE FROM videos
//	WHERE id = $1
func (q *Queries) DeleteVideo(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteVideo, id)
	return err
}

const insertVideo = `-- name: InsertVideo :one
INSERT INTO videos (
    id,
    src,
    archived_by,
    title,
    thumb_gradient_start,
    thumb_gradient_end,
    thumb_gradient_angle,
    description,
    tags,
    uploader,
    uploader_id,
    channel_id,
    upload_date,
    duration_seconds,
    view_count,
    like_count,
    info,
    comments,
    video_path,
    thumbnail_path,
    file_hash,
    file_size,
    probe_data,
    search
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    CASE
        WHEN ($13::text) IS NULL OR btrim($13::text) = '' THEN NULL
        WHEN ($13::text) ~ '^[0-9]{8}$' THEN to_date($13::text, 'YYYYMMDD')
        ELSE ($13::text)::date
    END,
    $14,
    $15,
    $16,
    $17,
    $18,
    $19,
    $20,
    $21,
    $22,
    $23,
    to_tsvector('simple'::regconfig,
        coalesce($4, '') || ' ' ||
        coalesce($8, '') || ' ' ||
        coalesce(array_to_string($9::text[], ' '), '')
    )
)
ON CONFLICT (src)
DO UPDATE SET
    updated_at = NOW(),
    title = EXCLUDED.title,
    thumb_gradient_start = COALESCE(EXCLUDED.thumb_gradient_start, videos.thumb_gradient_start),
    thumb_gradient_end = COALESCE(EXCLUDED.thumb_gradient_end, videos.thumb_gradient_end),
    thumb_gradient_angle = COALESCE(EXCLUDED.thumb_gradient_angle, videos.thumb_gradient_angle),
    description = EXCLUDED.description,
    tags = EXCLUDED.tags,
    uploader = EXCLUDED.uploader,
    uploader_id = EXCLUDED.uploader_id,
    channel_id = EXCLUDED.channel_id,
    upload_date = EXCLUDED.upload_date,
    duration_seconds = EXCLUDED.duration_seconds,
    view_count = EXCLUDED.view_count,
    like_count = EXCLUDED.like_count,
    info = EXCLUDED.info,
    comments = EXCLUDED.comments,
    video_path = EXCLUDED.video_path,
    thumbnail_path = EXCLUDED.thumbnail_path,
    file_hash = EXCLUDED.file_hash,
    file_size = EXCLUDED.file_size,
    probe_data = COALESCE(EXCLUDED.probe_data, videos.probe_data),
    search = EXCLUDED.search
RETURNING id, created_at, updated_at, src, archived_by, title, info, comments, video_path, thumbnail_path, description, tags, uploader, uploader_id, channel_id, upload_date, duration_seconds, view_count, like_count, thumb_gradient_start, thumb_gradient_end, thumb_gradient_angle, file_hash, file_size, assets_status, search, probe_data
`

type InsertVideoParams struct {
	ID                 pgtype.UUID          `db:"id" json:"ID"`
	Src                string               `db:"src" json:"Src"`
	ArchivedBy         pgtype.UUID          `db:"archived_by" json:"ArchivedBy"`
	Title              string               `db:"title" json:"Title"`
	ThumbGradientStart *string              `db:"thumb_gradient_start" json:"ThumbGradientStart"`
	ThumbGradientEnd   *string              `db:"thumb_gradient_end" json:"ThumbGradientEnd"`
	ThumbGradientAngle *int32               `db:"thumb_gradient_angle" json:"ThumbGradientAngle"`
	Description        string               `db:"description" json:"Description"`
	Tags               []string             `db:"tags" json:"Tags"`
	Uploader           string               `db:"uploader" json:"Uploader"`
	UploaderID         *string              `db:"uploader_id" json:"UploaderID"`
	ChannelID          *string              `db:"channel_id" json:"ChannelID"`
	UploadDate         *string              `db:"upload_date" json:"UploadDate"`
	DurationSeconds    *int32               `db:"duration_seconds" json:"DurationSeconds"`
	ViewCount          *int64               `db:"view_count" json:"ViewCount"`
	LikeCount          *int64               `db:"like_count" json:"LikeCount"`
	Info               videoinfo.VideoInfo  `db:"info" json:"Info"`
	Comments           []byte               `db:"comments" json:"Comments"`
	VideoPath          *string              `db:"video_path" json:"VideoPath"`
	ThumbnailPath      *string              `db:"thumbnail_path" json:"ThumbnailPath"`
	FileHash           *string              `db:"file_hash" json:"FileHash"`
	FileSize           *int64               `db:"file_size" json:"FileSize"`
	ProbeData          *videoinfo.ProbeInfo `db:"probe_data" json:"ProbeData"`
}

// InsertVideo inserts a video row.
//
//	INSERT INTO videos (
//	    id,
//	    src,
//	    archived_by,
//	    title,
//	    thumb_gradient_start,
//	    thumb_gradient_end,
//	    thumb_gradient_angle,
//	    description,
//	    tags,
//	    uploader,
//	    uploader_id,
//	    channel_id,
//	    upload_date,
//	    duration_seconds,
//	    view_count,
//	    like_count,
//	    info,
//	    comments,
//	    video_path,
//	    thumbnail_path,
//	    file_hash,
//	    file_size,
//	    probe_data,
//	    search
//	)
//	VALUES (
//	    $1,
//	    $2,
//	    $3,
//	    $4,
//	    $5,
//	    $6,
//	    $7,
//	    $8,
//	    $9,
//	    $10,
//	    $11,
//	    $12,
//	    CASE
//	        WHEN ($13::text) IS NULL OR btrim($13::text) = '' THEN NULL
//	        WHEN ($13::text) ~ '^[0-9]{8}$' THEN to_date($13::text, 'YYYYMMDD')
//	        ELSE ($13::text)::date
//	    END,
//	    $14,
//	    $15,
//	    $16,
//	    $17,
//	    $18,
//	    $19,
//	    $20,
//	    $21,
//	    $22,
//	    $23,
//	    to_tsvector('simple'::regconfig,
//	        coalesce($4, '') || ' ' ||
//	        coalesce($8, '') || ' ' ||
//	        coalesce(array_to_string($9::text[], ' '), '')
//	    )
//	)
//	ON CONFLICT (src)
//	DO UPDATE SET
//	    updated_at = NOW(),
//	    title = EXCLUDED.title,
//	    thumb_gradient_start = COALESCE(EXCLUDED.thumb_gradient_start, videos.thumb_gradient_start),
//	    thumb_gradient_end = COALESCE(EXCLUDED.thumb_gradient_end, videos.thumb_gradient_end),
//	    thumb_gradient_angle = COALESCE(EXCLUDED.thumb_gradient_angle, videos.thumb_gradient_angle),
//	    description = EXCLUDED.description,
//	    tags = EXCLUDED.tags,
//	    uploader = EXCLUDED.uploader,
//	    uploader_id = EXCLUDED.uploader_id,
//	    channel_id = EXCLUDED.channel_id,
//	    upload_date = EXCLUDED.upload_date,
//	    duration_seconds = EXCLUDED.duration_seconds,
//	    view_count = EXCLUDED.view_count,
//	    like_count = EXCLUDED.like_count,
//	    info = EXCLUDED.info,
//	    comments = EXCLUDED.comments,
//	    video_path = EXCLUDED.video_path,
//	    thumbnail_path = EXCLUDED.thumbnail_path,
//	    file_hash = EXCLUDED.file_hash,
//	    file_size = EXCLUDED.file_size,
//	    probe_data = COALESCE(EXCLUDED.probe_data, videos.probe_data),
//	    search = EXCLUDED.search
//	RETURNING id, created_at, updated_at, src, archived_by, title, info, comments, video_path, thumbnail_path, description, tags, uploader, uploader_id, channel_id, upload_date, duration_seconds, view_count, like_count, thumb_gradient_start, thumb_gradient_end, thumb_gradient_angle, file_hash, file_size, assets_status, search, probe_data
func (q *Queries) InsertVideo(ctx context.Context, arg *InsertVideoParams) (*Video, error) {
	row := q.db.QueryRow(ctx, insertVideo,
		arg.ID,
		arg.Src,
		arg.ArchivedBy,
		arg.Title,
		arg.ThumbGradientStart,
		arg.ThumbGradientEnd,
		arg.ThumbGradientAngle,
		arg.Description,
		arg.Tags,
		arg.Uploader,
		arg.UploaderID,
		arg.ChannelID,
		arg.UploadDate,
		arg.DurationSeconds,
		arg.ViewCount,
		arg.LikeCount,
		arg.Info,
		arg.Comments,
		arg.VideoPath,
		arg.ThumbnailPath,
		arg.FileHash,
		arg.FileSize,
		arg.ProbeData,
	)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Src,
		&i.ArchivedBy,
		&i.Title,
		&i.Info,
		&i.Comments,
		&i.VideoPath,
		&i.ThumbnailPath,
		&i.Description,
		&i.Tags,
		&i.Uploader,
		&i.UploaderID,
		&i.ChannelID,
		&i.UploadDate,
		&i.DurationSeconds,
		&i.ViewCount,
		&i.LikeCount,
		&i.ThumbGradientStart,
		&i.ThumbGradientEnd,
		&i.ThumbGradientAngle,
		&i.FileHash,
		&i.FileSize,
		&i.AssetsStatus,
		&i.Search,
		&i.ProbeData,
	)
	return &i, err
}

const listVideosForAssetCatchup = `-- name: ListVideosForAssetCatchup :many
SELECT id::text, video_path, thumbnail_path, file_hash, duration_seconds, assets_status
FROM videos
WHERE video_path IS NOT NULL AND btrim(video_path) <> ''
AND (
    assets_status = '{}'::jsonb
    OR NOT (assets_status ?& array['thumbnail','preview','waveform','file_hash','seek'])
    OR assets_status @> '{"thumbnail": false}'::jsonb
    OR assets_status @> '{"preview": false}'::jsonb
    OR assets_status @> '{"waveform": false}'::jsonb
    OR assets_status @> '{"file_hash": false}'::jsonb
    OR assets_status @> '{"seek": false}'::jsonb
)
AND (
    -- No errors yet, or backoff period has elapsed.
    -- Backoff: 2^error_count minutes (1=2m, 2=4m, 3=8m, ... 10+=~17h cap).
    NOT (assets_status ? '_error_count')
    OR (assets_status->>'_error_count')::int < 1
    OR (
        assets_status ? '_last_error_at'
        AND (assets_status->>'_last_error_at')::timestamptz
            + (LEAST(POWER(2, LEAST((assets_status->>'_error_count')::int, 10)), 1024) || ' minutes')::interval
            < NOW()
    )
)
ORDER BY updated_at ASC
LIMIT $1
`

type ListVideosForAssetCatchupRow struct {
	ID              string   `db:"id" json:"ID"`
	VideoPath       *string  `db:"video_path" json:"VideoPath"`
	ThumbnailPath   *string  `db:"thumbnail_path" json:"ThumbnailPath"`
	FileHash        *string  `db:"file_hash" json:"FileHash"`
	DurationSeconds *int32   `db:"duration_seconds" json:"DurationSeconds"`
	AssetsStatus    AssetMap `db:"assets_status" json:"AssetsStatus"`
}

// ListVideosForAssetCatchup returns videos that are missing one or more generated assets.
// Videos with recent errors are backed off exponentially based on _error_count.
//
//	SELECT id::text, video_path, thumbnail_path, file_hash, duration_seconds, assets_status
//	FROM videos
//	WHERE video_path IS NOT NULL AND btrim(video_path) <> ''
//	AND (
//	    assets_status = '{}'::jsonb
//	    OR NOT (assets_status ?& array['thumbnail','preview','waveform','file_hash','seek'])
//	    OR assets_status @> '{"thumbnail": false}'::jsonb
//	    OR assets_status @> '{"preview": false}'::jsonb
//	    OR assets_status @> '{"waveform": false}'::jsonb
//	    OR assets_status @> '{"file_hash": false}'::jsonb
//	    OR assets_status @> '{"seek": false}'::jsonb
//	)
//	AND (
//	    -- No errors yet, or backoff period has elapsed.
//	    -- Backoff: 2^error_count minutes (1=2m, 2=4m, 3=8m, ... 10+=~17h cap).
//	    NOT (assets_status ? '_error_count')
//	    OR (assets_status->>'_error_count')::int < 1
//	    OR (
//	        assets_status ? '_last_error_at'
//	        AND (assets_status->>'_last_error_at')::timestamptz
//	            + (LEAST(POWER(2, LEAST((assets_status->>'_error_count')::int, 10)), 1024) || ' minutes')::interval
//	            < NOW()
//	    )
//	)
//	ORDER BY updated_at ASC
//	LIMIT $1
func (q *Queries) ListVideosForAssetCatchup(ctx context.Context, limit int32) ([]*ListVideosForAssetCatchupRow, error) {
	rows, err := q.db.Query(ctx, listVideosForAssetCatchup, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListVideosForAssetCatchupRow
	for rows.Next() {
		var i ListVideosForAssetCatchupRow
		if err := rows.Scan(
			&i.ID,
			&i.VideoPath,
			&i.ThumbnailPath,
			&i.FileHash,
			&i.DurationSeconds,
			&i.AssetsStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideosNeedingProbe = `-- name: ListVideosNeedingProbe :many
SELECT id, video_path
FROM videos
WHERE video_path IS NOT NULL AND btrim(video_path) <> ''
  AND probe_data IS NULL
ORDER BY created_at DESC
LIMIT $1
`

type ListVideosNeedingProbeRow struct {
	ID        pgtype.UUID `db:"id" json:"ID"`
	VideoPath *string     `db:"video_path" json:"VideoPath"`
}

// ListVideosNeedingProbe returns videos with a video_path but no probe_data, for backfill.
//
//	SELECT id, video_path
//	FROM videos
//	WHERE video_path IS NOT NULL AND btrim(video_path) <> ''
//	  AND probe_data IS NULL
//	ORDER BY created_at DESC
//	LIMIT $1
func (q *Queries) ListVideosNeedingProbe(ctx context.Context, maxCount int32) ([]*ListVideosNeedingProbeRow, error) {
	rows, err := q.db.Query(ctx, listVideosNeedingProbe, maxCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListVideosNeedingProbeRow
	for rows.Next() {
		var i ListVideosNeedingProbeRow
		if err := rows.Scan(&i.ID, &i.VideoPath); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideosWithAssetErrors = `-- name: ListVideosWithAssetErrors :many
SELECT id::text, title, video_path, assets_status, updated_at
FROM videos
WHERE video_path IS NOT NULL AND btrim(video_path) <> ''
AND assets_status ? '_error_count'
AND (assets_status->>'_error_count')::int > 0
ORDER BY (assets_status->>'_last_error_at')::timestamptz DESC NULLS LAST
LIMIT $1
`

type ListVideosWithAssetErrorsRow struct {
	ID           string             `db:"id" json:"ID"`
	Title        string             `db:"title" json:"Title"`
	VideoPath    *string            `db:"video_path" json:"VideoPath"`
	AssetsStatus AssetMap           `db:"assets_status" json:"AssetsStatus"`
	UpdatedAt    pgtype.Timestamptz `db:"updated_at" json:"UpdatedAt"`
}

// ListVideosWithAssetErrors returns videos that have recorded asset generation errors.
//
//	SELECT id::text, title, video_path, assets_status, updated_at
//	FROM videos
//	WHERE video_path IS NOT NULL AND btrim(video_path) <> ''
//	AND assets_status ? '_error_count'
//	AND (assets_status->>'_error_count')::int > 0
//	ORDER BY (assets_status->>'_last_error_at')::timestamptz DESC NULLS LAST
//	LIMIT $1
func (q *Queries) ListVideosWithAssetErrors(ctx context.Context, limit int32) ([]*ListVideosWithAssetErrorsRow, error) {
	rows, err := q.db.Query(ctx, listVideosWithAssetErrors, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListVideosWithAssetErrorsRow
	for rows.Next() {
		var i ListVideosWithAssetErrorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.VideoPath,
			&i.AssetsStatus,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVideoBySrc = `-- name: SelectVideoBySrc :one
SELECT id, created_at, updated_at, src, archived_by, title, info, comments, video_path, thumbnail_path, description, tags, uploader, uploader_id, channel_id, upload_date, duration_seconds, view_count, like_count, thumb_gradient_start, thumb_gradient_end, thumb_gradient_angle, file_hash, file_size, assets_status, search, probe_data
FROM videos
WHERE src = $1
`

// SelectVideoBySrc returns a video by src.
//
//	SELECT id, created_at, updated_at, src, archived_by, title, info, comments, video_path, thumbnail_path, description, tags, uploader, uploader_id, channel_id, upload_date, duration_seconds, view_count, like_count, thumb_gradient_start, thumb_gradient_end, thumb_gradient_angle, file_hash, file_size, assets_status, search, probe_data
//	FROM videos
//	WHERE src = $1
func (q *Queries) SelectVideoBySrc(ctx context.Context, src string) (*Video, error) {
	row := q.db.QueryRow(ctx, selectVideoBySrc, src)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Src,
		&i.ArchivedBy,
		&i.Title,
		&i.Info,
		&i.Comments,
		&i.VideoPath,
		&i.ThumbnailPath,
		&i.Description,
		&i.Tags,
		&i.Uploader,
		&i.UploaderID,
		&i.ChannelID,
		&i.UploadDate,
		&i.DurationSeconds,
		&i.ViewCount,
		&i.LikeCount,
		&i.ThumbGradientStart,
		&i.ThumbGradientEnd,
		&i.ThumbGradientAngle,
		&i.FileHash,
		&i.FileSize,
		&i.AssetsStatus,
		&i.Search,
		&i.ProbeData,
	)
	return &i, err
}

const updateVideoAssetsStatus = `-- name: UpdateVideoAssetsStatus :exec
UPDATE videos
SET assets_status = COALESCE(assets_status, '{}'::jsonb) || $1::asset_status_map,
    updated_at = NOW()
WHERE id = $2
`

type UpdateVideoAssetsStatusParams struct {
	AssetsStatus AssetMap    `db:"assets_status" json:"AssetsStatus"`
	ID           pgtype.UUID `db:"id" json:"ID"`
}

// UpdateVideoAssetsStatus merges asset status flags into videos.assets_status.
//
//	UPDATE videos
//	SET assets_status = COALESCE(assets_status, '{}'::jsonb) || $1::asset_status_map,
//	    updated_at = NOW()
//	WHERE id = $2
func (q *Queries) UpdateVideoAssetsStatus(ctx context.Context, arg *UpdateVideoAssetsStatusParams) error {
	_, err := q.db.Exec(ctx, updateVideoAssetsStatus, arg.AssetsStatus, arg.ID)
	return err
}

const updateVideoFileHashAndSize = `-- name: UpdateVideoFileHashAndSize :exec
UPDATE videos
SET file_hash = $1,
    file_size = $2,
    updated_at = NOW()
WHERE id = $3
`

type UpdateVideoFileHashAndSizeParams struct {
	FileHash *string     `db:"file_hash" json:"FileHash"`
	FileSize *int64      `db:"file_size" json:"FileSize"`
	ID       pgtype.UUID `db:"id" json:"ID"`
}

// UpdateVideoFileHashAndSize updates file_hash + file_size for a video.
//
//	UPDATE videos
//	SET file_hash = $1,
//	    file_size = $2,
//	    updated_at = NOW()
//	WHERE id = $3
func (q *Queries) UpdateVideoFileHashAndSize(ctx context.Context, arg *UpdateVideoFileHashAndSizeParams) error {
	_, err := q.db.Exec(ctx, updateVideoFileHashAndSize, arg.FileHash, arg.FileSize, arg.ID)
	return err
}

const updateVideoPath = `-- name: UpdateVideoPath :exec
UPDATE videos
SET video_path = $1,
    updated_at = NOW()
WHERE id = $2
`

type UpdateVideoPathParams struct {
	VideoPath *string     `db:"video_path" json:"VideoPath"`
	ID        pgtype.UUID `db:"id" json:"ID"`
}

// UpdateVideoPath updates the video_path for a video.
//
//	UPDATE videos
//	SET video_path = $1,
//	    updated_at = NOW()
//	WHERE id = $2
func (q *Queries) UpdateVideoPath(ctx context.Context, arg *UpdateVideoPathParams) error {
	_, err := q.db.Exec(ctx, updateVideoPath, arg.VideoPath, arg.ID)
	return err
}

const updateVideoProbeData = `-- name: UpdateVideoProbeData :exec
UPDATE videos
SET probe_data = $1,
    updated_at = NOW()
WHERE id = $2
`

type UpdateVideoProbeDataParams struct {
	ProbeData *videoinfo.ProbeInfo `db:"probe_data" json:"ProbeData"`
	ID        pgtype.UUID          `db:"id" json:"ID"`
}

// UpdateVideoProbeData stores ffprobe data for a video.
//
//	UPDATE videos
//	SET probe_data = $1,
//	    updated_at = NOW()
//	WHERE id = $2
func (q *Queries) UpdateVideoProbeData(ctx context.Context, arg *UpdateVideoProbeDataParams) error {
	_, err := q.db.Exec(ctx, updateVideoProbeData, arg.ProbeData, arg.ID)
	return err
}

const updateVideoThumbnailPath = `-- name: UpdateVideoThumbnailPath :exec
UPDATE videos
SET thumbnail_path = $1,
    updated_at = NOW()
WHERE id = $2
`

type UpdateVideoThumbnailPathParams struct {
	ThumbnailPath *string     `db:"thumbnail_path" json:"ThumbnailPath"`
	ID            pgtype.UUID `db:"id" json:"ID"`
}

// UpdateVideoThumbnailPath updates the thumbnail_path for a video.
//
//	UPDATE videos
//	SET thumbnail_path = $1,
//	    updated_at = NOW()
//	WHERE id = $2
func (q *Queries) UpdateVideoThumbnailPath(ctx context.Context, arg *UpdateVideoThumbnailPathParams) error {
	_, err := q.db.Exec(ctx, updateVideoThumbnailPath, arg.ThumbnailPath, arg.ID)
	return err
}
