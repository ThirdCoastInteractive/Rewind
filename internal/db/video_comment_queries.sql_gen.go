// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: video_comment_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countVideoComments = `-- name: CountVideoComments :one
SELECT COUNT(*)
FROM video_comments
WHERE video_id = $1
`

// CountVideoComments returns total comments ingested for a video.
//
//	SELECT COUNT(*)
//	FROM video_comments
//	WHERE video_id = $1
func (q *Queries) CountVideoComments(ctx context.Context, videoID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countVideoComments, videoID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listVideoCommentReplies = `-- name: ListVideoCommentReplies :many
SELECT id, video_id, source, comment_id, parent_id, author, author_id, author_url,
       published_at, like_count, text, created_at
FROM video_comments
WHERE video_id = $1
  AND parent_id = $2::text
ORDER BY published_at ASC NULLS LAST
LIMIT 50
`

type ListVideoCommentRepliesParams struct {
	VideoID         pgtype.UUID `db:"video_id" json:"VideoID"`
	ParentCommentID string      `db:"parent_comment_id" json:"ParentCommentID"`
}

type ListVideoCommentRepliesRow struct {
	ID          pgtype.UUID        `db:"id" json:"ID"`
	VideoID     pgtype.UUID        `db:"video_id" json:"VideoID"`
	Source      string             `db:"source" json:"Source"`
	CommentID   string             `db:"comment_id" json:"CommentID"`
	ParentID    *string            `db:"parent_id" json:"ParentID"`
	Author      *string            `db:"author" json:"Author"`
	AuthorID    *string            `db:"author_id" json:"AuthorID"`
	AuthorURL   *string            `db:"author_url" json:"AuthorUrl"`
	PublishedAt pgtype.Timestamptz `db:"published_at" json:"PublishedAt"`
	LikeCount   *int64             `db:"like_count" json:"LikeCount"`
	Text        *string            `db:"text" json:"Text"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"CreatedAt"`
}

// ListVideoCommentReplies returns replies (children) for a given parent comment.
//
//	SELECT id, video_id, source, comment_id, parent_id, author, author_id, author_url,
//	       published_at, like_count, text, created_at
//	FROM video_comments
//	WHERE video_id = $1
//	  AND parent_id = $2::text
//	ORDER BY published_at ASC NULLS LAST
//	LIMIT 50
func (q *Queries) ListVideoCommentReplies(ctx context.Context, arg *ListVideoCommentRepliesParams) ([]*ListVideoCommentRepliesRow, error) {
	rows, err := q.db.Query(ctx, listVideoCommentReplies, arg.VideoID, arg.ParentCommentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListVideoCommentRepliesRow
	for rows.Next() {
		var i ListVideoCommentRepliesRow
		if err := rows.Scan(
			&i.ID,
			&i.VideoID,
			&i.Source,
			&i.CommentID,
			&i.ParentID,
			&i.Author,
			&i.AuthorID,
			&i.AuthorURL,
			&i.PublishedAt,
			&i.LikeCount,
			&i.Text,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideoComments = `-- name: ListVideoComments :many
SELECT id, video_id, source, comment_id, parent_id, author, author_id, author_url,
       published_at, like_count, text, created_at
FROM video_comments
WHERE video_id = $1
  AND (parent_id IS NULL OR parent_id = 'root')
ORDER BY COALESCE(like_count, 0) DESC, published_at DESC NULLS LAST
LIMIT $3::int
OFFSET $2::int
`

type ListVideoCommentsParams struct {
	VideoID    pgtype.UUID `db:"video_id" json:"VideoID"`
	PageOffset int32       `db:"page_offset" json:"PageOffset"`
	PageSize   int32       `db:"page_size" json:"PageSize"`
}

type ListVideoCommentsRow struct {
	ID          pgtype.UUID        `db:"id" json:"ID"`
	VideoID     pgtype.UUID        `db:"video_id" json:"VideoID"`
	Source      string             `db:"source" json:"Source"`
	CommentID   string             `db:"comment_id" json:"CommentID"`
	ParentID    *string            `db:"parent_id" json:"ParentID"`
	Author      *string            `db:"author" json:"Author"`
	AuthorID    *string            `db:"author_id" json:"AuthorID"`
	AuthorURL   *string            `db:"author_url" json:"AuthorUrl"`
	PublishedAt pgtype.Timestamptz `db:"published_at" json:"PublishedAt"`
	LikeCount   *int64             `db:"like_count" json:"LikeCount"`
	Text        *string            `db:"text" json:"Text"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"CreatedAt"`
}

// ListVideoComments returns paginated top-level comments for a video.
// Top-level = parent_id IS NULL or parent_id = 'root'.
// Ordered by like_count DESC, then published_at DESC.
//
//	SELECT id, video_id, source, comment_id, parent_id, author, author_id, author_url,
//	       published_at, like_count, text, created_at
//	FROM video_comments
//	WHERE video_id = $1
//	  AND (parent_id IS NULL OR parent_id = 'root')
//	ORDER BY COALESCE(like_count, 0) DESC, published_at DESC NULLS LAST
//	LIMIT $3::int
//	OFFSET $2::int
func (q *Queries) ListVideoComments(ctx context.Context, arg *ListVideoCommentsParams) ([]*ListVideoCommentsRow, error) {
	rows, err := q.db.Query(ctx, listVideoComments, arg.VideoID, arg.PageOffset, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListVideoCommentsRow
	for rows.Next() {
		var i ListVideoCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.VideoID,
			&i.Source,
			&i.CommentID,
			&i.ParentID,
			&i.Author,
			&i.AuthorID,
			&i.AuthorURL,
			&i.PublishedAt,
			&i.LikeCount,
			&i.Text,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchVideoComments = `-- name: SearchVideoComments :many
SELECT id, video_id, source, comment_id, parent_id, author, author_id, author_url,
       published_at, like_count, text, created_at
FROM video_comments
WHERE video_id = $1
  AND search @@ plainto_tsquery('simple', $2::text)
ORDER BY COALESCE(like_count, 0) DESC
LIMIT $4::int
OFFSET $3::int
`

type SearchVideoCommentsParams struct {
	VideoID    pgtype.UUID `db:"video_id" json:"VideoID"`
	Query      string      `db:"query" json:"Query"`
	PageOffset int32       `db:"page_offset" json:"PageOffset"`
	PageSize   int32       `db:"page_size" json:"PageSize"`
}

type SearchVideoCommentsRow struct {
	ID          pgtype.UUID        `db:"id" json:"ID"`
	VideoID     pgtype.UUID        `db:"video_id" json:"VideoID"`
	Source      string             `db:"source" json:"Source"`
	CommentID   string             `db:"comment_id" json:"CommentID"`
	ParentID    *string            `db:"parent_id" json:"ParentID"`
	Author      *string            `db:"author" json:"Author"`
	AuthorID    *string            `db:"author_id" json:"AuthorID"`
	AuthorURL   *string            `db:"author_url" json:"AuthorUrl"`
	PublishedAt pgtype.Timestamptz `db:"published_at" json:"PublishedAt"`
	LikeCount   *int64             `db:"like_count" json:"LikeCount"`
	Text        *string            `db:"text" json:"Text"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"CreatedAt"`
}

// SearchVideoComments returns comments matching a text search query.
//
//	SELECT id, video_id, source, comment_id, parent_id, author, author_id, author_url,
//	       published_at, like_count, text, created_at
//	FROM video_comments
//	WHERE video_id = $1
//	  AND search @@ plainto_tsquery('simple', $2::text)
//	ORDER BY COALESCE(like_count, 0) DESC
//	LIMIT $4::int
//	OFFSET $3::int
func (q *Queries) SearchVideoComments(ctx context.Context, arg *SearchVideoCommentsParams) ([]*SearchVideoCommentsRow, error) {
	rows, err := q.db.Query(ctx, searchVideoComments,
		arg.VideoID,
		arg.Query,
		arg.PageOffset,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchVideoCommentsRow
	for rows.Next() {
		var i SearchVideoCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.VideoID,
			&i.Source,
			&i.CommentID,
			&i.ParentID,
			&i.Author,
			&i.AuthorID,
			&i.AuthorURL,
			&i.PublishedAt,
			&i.LikeCount,
			&i.Text,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertVideoCommentsFromJSON = `-- name: UpsertVideoCommentsFromJSON :exec
INSERT INTO video_comments (
    video_id,
    source,
    comment_id,
    parent_id,
    author,
    author_id,
    author_url,
    published_at,
    like_count,
    text,
    search,
    raw,
    updated_at
)
SELECT
    $1::uuid AS video_id,
    $2::text AS source,
    c->>'id' AS comment_id,
    COALESCE(NULLIF(c->>'parent', ''), NULLIF(c->>'parent_id', '')) AS parent_id,
    NULLIF(c->>'author', '') AS author,
    NULLIF(c->>'author_id', '') AS author_id,
    NULLIF(c->>'author_url', '') AS author_url,
    CASE
        WHEN (c->>'timestamp') ~ '^[0-9]+(\\.[0-9]+)?$' THEN to_timestamp((c->>'timestamp')::double precision)
        ELSE NULL
    END AS published_at,
    CASE
        WHEN (c->>'like_count') ~ '^-?[0-9]+$' THEN (c->>'like_count')::bigint
        ELSE NULL
    END AS like_count,
    COALESCE(NULLIF(c->>'text', ''), NULLIF(c->>'content', ''), NULLIF(c->>'comment', '')) AS text,
    to_tsvector('simple'::regconfig,
        coalesce(COALESCE(NULLIF(c->>'text', ''), NULLIF(c->>'content', ''), NULLIF(c->>'comment', '')), '')
        || ' ' ||
        coalesce(NULLIF(c->>'author', ''), '')
    ) AS search,
    c AS raw,
    NOW() AS updated_at
FROM jsonb_array_elements($3::jsonb) AS c
WHERE COALESCE(NULLIF(c->>'id', ''), '') <> ''
ON CONFLICT (video_id, source, comment_id)
DO UPDATE SET
    parent_id = EXCLUDED.parent_id,
    author = EXCLUDED.author,
    author_id = EXCLUDED.author_id,
    author_url = EXCLUDED.author_url,
    published_at = EXCLUDED.published_at,
    like_count = EXCLUDED.like_count,
    text = EXCLUDED.text,
    search = EXCLUDED.search,
    raw = EXCLUDED.raw,
    updated_at = NOW()
`

type UpsertVideoCommentsFromJSONParams struct {
	VideoID      pgtype.UUID `db:"video_id" json:"VideoID"`
	Source       string      `db:"source" json:"Source"`
	CommentsJson []byte      `db:"comments_json" json:"CommentsJson"`
}

// UpsertVideoCommentsFromJSON ingests a JSON array of yt-dlp comment objects.
// It extracts common fields for indexing/search and stores the full raw object.
//
// Required JSON shape: a JSON array of objects. Elements without an id are skipped.
//
//	INSERT INTO video_comments (
//	    video_id,
//	    source,
//	    comment_id,
//	    parent_id,
//	    author,
//	    author_id,
//	    author_url,
//	    published_at,
//	    like_count,
//	    text,
//	    search,
//	    raw,
//	    updated_at
//	)
//	SELECT
//	    $1::uuid AS video_id,
//	    $2::text AS source,
//	    c->>'id' AS comment_id,
//	    COALESCE(NULLIF(c->>'parent', ''), NULLIF(c->>'parent_id', '')) AS parent_id,
//	    NULLIF(c->>'author', '') AS author,
//	    NULLIF(c->>'author_id', '') AS author_id,
//	    NULLIF(c->>'author_url', '') AS author_url,
//	    CASE
//	        WHEN (c->>'timestamp') ~ '^[0-9]+(\\.[0-9]+)?$' THEN to_timestamp((c->>'timestamp')::double precision)
//	        ELSE NULL
//	    END AS published_at,
//	    CASE
//	        WHEN (c->>'like_count') ~ '^-?[0-9]+$' THEN (c->>'like_count')::bigint
//	        ELSE NULL
//	    END AS like_count,
//	    COALESCE(NULLIF(c->>'text', ''), NULLIF(c->>'content', ''), NULLIF(c->>'comment', '')) AS text,
//	    to_tsvector('simple'::regconfig,
//	        coalesce(COALESCE(NULLIF(c->>'text', ''), NULLIF(c->>'content', ''), NULLIF(c->>'comment', '')), '')
//	        || ' ' ||
//	        coalesce(NULLIF(c->>'author', ''), '')
//	    ) AS search,
//	    c AS raw,
//	    NOW() AS updated_at
//	FROM jsonb_array_elements($3::jsonb) AS c
//	WHERE COALESCE(NULLIF(c->>'id', ''), '') <> ''
//	ON CONFLICT (video_id, source, comment_id)
//	DO UPDATE SET
//	    parent_id = EXCLUDED.parent_id,
//	    author = EXCLUDED.author,
//	    author_id = EXCLUDED.author_id,
//	    author_url = EXCLUDED.author_url,
//	    published_at = EXCLUDED.published_at,
//	    like_count = EXCLUDED.like_count,
//	    text = EXCLUDED.text,
//	    search = EXCLUDED.search,
//	    raw = EXCLUDED.raw,
//	    updated_at = NOW()
func (q *Queries) UpsertVideoCommentsFromJSON(ctx context.Context, arg *UpsertVideoCommentsFromJSONParams) error {
	_, err := q.db.Exec(ctx, upsertVideoCommentsFromJSON, arg.VideoID, arg.Source, arg.CommentsJson)
	return err
}
