// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"thirdcoast.systems/rewind/pkg/utils/passwords"
)

const countEnabledAdmins = `-- name: CountEnabledAdmins :one
SELECT COUNT(*)::bigint FROM users WHERE deleted_at IS NULL AND enabled = TRUE AND role = 'admin'
`

// CountEnabledAdmins counts enabled admin users
//
//	SELECT COUNT(*)::bigint FROM users WHERE deleted_at IS NULL AND enabled = TRUE AND role = 'admin'
func (q *Queries) CountEnabledAdmins(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countEnabledAdmins)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*)::bigint FROM users WHERE deleted_at IS NULL
`

// CountUsers counts non-deleted users
//
//	SELECT COUNT(*)::bigint FROM users WHERE deleted_at IS NULL
func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE users SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL
`

// DeleteUser soft deletes a user from the database
//
//	UPDATE users SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL
func (q *Queries) DeleteUser(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const emailRegistered = `-- name: EmailRegistered :one
SELECT EXISTS (
    SELECT 1
    FROM users
    WHERE email = $1 AND deleted_at IS NULL
)
`

// EmailRegistered checks if an email is already registered
//
//	SELECT EXISTS (
//	    SELECT 1
//	    FROM users
//	    WHERE email = $1 AND deleted_at IS NULL
//	)
func (q *Queries) EmailRegistered(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, emailRegistered, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getSessionInvalidation = `-- name: GetSessionInvalidation :one
SELECT sessions_invalidated_at, enabled
FROM users
WHERE id = $1 AND deleted_at IS NULL
`

type GetSessionInvalidationRow struct {
	SessionsInvalidatedAt pgtype.Timestamptz `db:"sessions_invalidated_at" json:"SessionsInvalidatedAt"`
	Enabled               bool               `db:"enabled" json:"Enabled"`
}

// GetSessionInvalidation returns the sessions_invalidated_at and enabled
// flag for a user. Used by middleware to check if a session is still valid.
//
//	SELECT sessions_invalidated_at, enabled
//	FROM users
//	WHERE id = $1 AND deleted_at IS NULL
func (q *Queries) GetSessionInvalidation(ctx context.Context, id pgtype.UUID) (*GetSessionInvalidationRow, error) {
	row := q.db.QueryRow(ctx, getSessionInvalidation, id)
	var i GetSessionInvalidationRow
	err := row.Scan(&i.SessionsInvalidatedAt, &i.Enabled)
	return &i, err
}

const invalidateUserSessions = `-- name: InvalidateUserSessions :exec
UPDATE users
SET sessions_invalidated_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

// InvalidateUserSessions marks all sessions for a user as invalid.
// Any session created before this timestamp will be rejected.
//
//	UPDATE users
//	SET sessions_invalidated_at = NOW(),
//	    updated_at = NOW()
//	WHERE id = $1 AND deleted_at IS NULL
func (q *Queries) InvalidateUserSessions(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, invalidateUserSessions, id)
	return err
}

const listAllUsers = `-- name: ListAllUsers :many
SELECT id, user_name, password, email, email_verified, verify_hash, enabled, role, created_at, updated_at, deleted_at, sessions_invalidated_at FROM users WHERE deleted_at IS NULL
`

// ListAllUsers lists all users in the database
//
//	SELECT id, user_name, password, email, email_verified, verify_hash, enabled, role, created_at, updated_at, deleted_at, sessions_invalidated_at FROM users WHERE deleted_at IS NULL
func (q *Queries) ListAllUsers(ctx context.Context) ([]*User, error) {
	rows, err := q.db.Query(ctx, listAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.UserName,
			&i.Password,
			&i.Email,
			&i.EmailVerified,
			&i.VerifyHash,
			&i.Enabled,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.SessionsInvalidatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUserByEmail = `-- name: SelectUserByEmail :one
SELECT id, user_name, password, email, email_verified, verify_hash, enabled, role, created_at, updated_at, deleted_at, sessions_invalidated_at FROM users WHERE email = $1 AND deleted_at IS NULL
`

// SelectUserByEmail selects a user by email from the database
//
//	SELECT id, user_name, password, email, email_verified, verify_hash, enabled, role, created_at, updated_at, deleted_at, sessions_invalidated_at FROM users WHERE email = $1 AND deleted_at IS NULL
func (q *Queries) SelectUserByEmail(ctx context.Context, email string) (*User, error) {
	row := q.db.QueryRow(ctx, selectUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Password,
		&i.Email,
		&i.EmailVerified,
		&i.VerifyHash,
		&i.Enabled,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.SessionsInvalidatedAt,
	)
	return &i, err
}

const selectUserByID = `-- name: SelectUserByID :one
SELECT id, user_name, password, email, email_verified, verify_hash, enabled, role, created_at, updated_at, deleted_at, sessions_invalidated_at FROM users WHERE id = $1 AND deleted_at IS NULL
`

// SelectUserByID selects a user by ID from the database
//
//	SELECT id, user_name, password, email, email_verified, verify_hash, enabled, role, created_at, updated_at, deleted_at, sessions_invalidated_at FROM users WHERE id = $1 AND deleted_at IS NULL
func (q *Queries) SelectUserByID(ctx context.Context, id pgtype.UUID) (*User, error) {
	row := q.db.QueryRow(ctx, selectUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Password,
		&i.Email,
		&i.EmailVerified,
		&i.VerifyHash,
		&i.Enabled,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.SessionsInvalidatedAt,
	)
	return &i, err
}

const selectUserByUserName = `-- name: SelectUserByUserName :one
SELECT id, user_name, password, email, email_verified, verify_hash, enabled, role, created_at, updated_at, deleted_at, sessions_invalidated_at FROM users WHERE user_name = $1 AND deleted_at IS NULL
`

// SelectUserByUserName selects a user by user name from the database
//
//	SELECT id, user_name, password, email, email_verified, verify_hash, enabled, role, created_at, updated_at, deleted_at, sessions_invalidated_at FROM users WHERE user_name = $1 AND deleted_at IS NULL
func (q *Queries) SelectUserByUserName(ctx context.Context, userName string) (*User, error) {
	row := q.db.QueryRow(ctx, selectUserByUserName, userName)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Password,
		&i.Email,
		&i.EmailVerified,
		&i.VerifyHash,
		&i.Enabled,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.SessionsInvalidatedAt,
	)
	return &i, err
}

const setUserEnabled = `-- name: SetUserEnabled :exec
UPDATE users
SET enabled = $1,
    updated_at = NOW()
WHERE id = $2 AND deleted_at IS NULL
`

type SetUserEnabledParams struct {
	Enabled bool        `db:"enabled" json:"Enabled"`
	ID      pgtype.UUID `db:"id" json:"ID"`
}

// SetUserEnabled updates a user's enabled flag
//
//	UPDATE users
//	SET enabled = $1,
//	    updated_at = NOW()
//	WHERE id = $2 AND deleted_at IS NULL
func (q *Queries) SetUserEnabled(ctx context.Context, arg *SetUserEnabledParams) error {
	_, err := q.db.Exec(ctx, setUserEnabled, arg.Enabled, arg.ID)
	return err
}

const setUserRole = `-- name: SetUserRole :exec
UPDATE users
SET role = $1,
    updated_at = NOW()
WHERE id = $2 AND deleted_at IS NULL
`

type SetUserRoleParams struct {
	Role UserRole    `db:"role" json:"Role"`
	ID   pgtype.UUID `db:"id" json:"ID"`
}

// SetUserRole updates a user's role
//
//	UPDATE users
//	SET role = $1,
//	    updated_at = NOW()
//	WHERE id = $2 AND deleted_at IS NULL
func (q *Queries) SetUserRole(ctx context.Context, arg *SetUserRoleParams) error {
	_, err := q.db.Exec(ctx, setUserRole, arg.Role, arg.ID)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET email = $1,
    password = $2,
    user_name = $3,
    updated_at = NOW(),
    email_verified = $4
WHERE id = $5 AND deleted_at IS NULL
`

type UpdateUserParams struct {
	Email         string             `db:"email" json:"Email"`
	Password      passwords.Password `db:"password" json:"Password"`
	UserName      string             `db:"user_name" json:"UserName"`
	EmailVerified bool               `db:"email_verified" json:"EmailVerified"`
	ID            pgtype.UUID        `db:"id" json:"ID"`
}

// UpdateUser updates a user in the database
//
//	UPDATE users
//	SET email = $1,
//	    password = $2,
//	    user_name = $3,
//	    updated_at = NOW(),
//	    email_verified = $4
//	WHERE id = $5 AND deleted_at IS NULL
func (q *Queries) UpdateUser(ctx context.Context, arg *UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.Email,
		arg.Password,
		arg.UserName,
		arg.EmailVerified,
		arg.ID,
	)
	return err
}

const usernameTaken = `-- name: UsernameTaken :one
SELECT EXISTS (
    SELECT 1
    FROM users
    WHERE user_name = $1 AND deleted_at IS NULL
)
`

// UsernameTaken checks if a username is already taken
//
//	SELECT EXISTS (
//	    SELECT 1
//	    FROM users
//	    WHERE user_name = $1 AND deleted_at IS NULL
//	)
func (q *Queries) UsernameTaken(ctx context.Context, userName string) (bool, error) {
	row := q.db.QueryRow(ctx, usernameTaken, userName)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const insertUser = `-- name: insertUser :one
INSERT INTO users (
    id,
    email,
    password,
    user_name,
    role,
    created_at,
    updated_at,
    deleted_at
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    NOW(),
    NOW(),
    NULL
)
RETURNING id, user_name, password, email, email_verified, verify_hash, enabled, role, created_at, updated_at, deleted_at, sessions_invalidated_at
`

type insertUserParams struct {
	ID       pgtype.UUID        `db:"id" json:"ID"`
	Email    string             `db:"email" json:"Email"`
	Password passwords.Password `db:"password" json:"Password"`
	UserName string             `db:"user_name" json:"UserName"`
	Role     UserRole           `db:"role" json:"Role"`
}

// insertUser inserts a user into the database
// it is intentionally kept private, user creation should be done via
// the NewUser helper found in internal/db/user.go
//
//	INSERT INTO users (
//	    id,
//	    email,
//	    password,
//	    user_name,
//	    role,
//	    created_at,
//	    updated_at,
//	    deleted_at
//	)
//	VALUES (
//	    $1,
//	    $2,
//	    $3,
//	    $4,
//	    $5,
//	    NOW(),
//	    NOW(),
//	    NULL
//	)
//	RETURNING id, user_name, password, email, email_verified, verify_hash, enabled, role, created_at, updated_at, deleted_at, sessions_invalidated_at
func (q *Queries) insertUser(ctx context.Context, arg *insertUserParams) (*User, error) {
	row := q.db.QueryRow(ctx, insertUser,
		arg.ID,
		arg.Email,
		arg.Password,
		arg.UserName,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Password,
		&i.Email,
		&i.EmailVerified,
		&i.VerifyHash,
		&i.Enabled,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.SessionsInvalidatedAt,
	)
	return &i, err
}
