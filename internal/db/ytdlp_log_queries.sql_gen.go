// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ytdlp_log_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countYtdlpLogsForJob = `-- name: CountYtdlpLogsForJob :one
SELECT COUNT(*) FROM ytdlp_logs WHERE job_id = $1
`

// CountYtdlpLogsForJob
//
//	SELECT COUNT(*) FROM ytdlp_logs WHERE job_id = $1
func (q *Queries) CountYtdlpLogsForJob(ctx context.Context, jobID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countYtdlpLogsForJob, jobID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getYtdlpLogsForJob = `-- name: GetYtdlpLogsForJob :many
SELECT id, job_id, stream, message, created_at
FROM ytdlp_logs
WHERE job_id = $1
ORDER BY created_at ASC, id ASC
`

// GetYtdlpLogsForJob
//
//	SELECT id, job_id, stream, message, created_at
//	FROM ytdlp_logs
//	WHERE job_id = $1
//	ORDER BY created_at ASC, id ASC
func (q *Queries) GetYtdlpLogsForJob(ctx context.Context, jobID pgtype.UUID) ([]*YtdlpLog, error) {
	rows, err := q.db.Query(ctx, getYtdlpLogsForJob, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*YtdlpLog
	for rows.Next() {
		var i YtdlpLog
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Stream,
			&i.Message,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYtdlpLogsForJobPaginated = `-- name: GetYtdlpLogsForJobPaginated :many
SELECT id, job_id, stream, message, created_at
FROM ytdlp_logs
WHERE job_id = $1
ORDER BY created_at DESC, id DESC
LIMIT $3 OFFSET $2
`

type GetYtdlpLogsForJobPaginatedParams struct {
	JobID      pgtype.UUID `db:"job_id" json:"JobID"`
	PageOffset int32       `db:"page_offset" json:"PageOffset"`
	PageLimit  int32       `db:"page_limit" json:"PageLimit"`
}

// GetYtdlpLogsForJobPaginated
//
//	SELECT id, job_id, stream, message, created_at
//	FROM ytdlp_logs
//	WHERE job_id = $1
//	ORDER BY created_at DESC, id DESC
//	LIMIT $3 OFFSET $2
func (q *Queries) GetYtdlpLogsForJobPaginated(ctx context.Context, arg *GetYtdlpLogsForJobPaginatedParams) ([]*YtdlpLog, error) {
	rows, err := q.db.Query(ctx, getYtdlpLogsForJobPaginated, arg.JobID, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*YtdlpLog
	for rows.Next() {
		var i YtdlpLog
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Stream,
			&i.Message,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYtdlpLogsForJobSince = `-- name: GetYtdlpLogsForJobSince :many
SELECT id, job_id, stream, message, created_at
FROM ytdlp_logs
WHERE job_id = $1 AND created_at > $2
ORDER BY created_at ASC, id ASC
`

type GetYtdlpLogsForJobSinceParams struct {
	JobID pgtype.UUID        `db:"job_id" json:"JobID"`
	Since pgtype.Timestamptz `db:"since" json:"Since"`
}

// GetYtdlpLogsForJobSince
//
//	SELECT id, job_id, stream, message, created_at
//	FROM ytdlp_logs
//	WHERE job_id = $1 AND created_at > $2
//	ORDER BY created_at ASC, id ASC
func (q *Queries) GetYtdlpLogsForJobSince(ctx context.Context, arg *GetYtdlpLogsForJobSinceParams) ([]*YtdlpLog, error) {
	rows, err := q.db.Query(ctx, getYtdlpLogsForJobSince, arg.JobID, arg.Since)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*YtdlpLog
	for rows.Next() {
		var i YtdlpLog
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Stream,
			&i.Message,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertYtdlpLog = `-- name: InsertYtdlpLog :exec
INSERT INTO ytdlp_logs (job_id, stream, message)
VALUES ($1, $2, $3)
`

type InsertYtdlpLogParams struct {
	JobID   pgtype.UUID `db:"job_id" json:"JobID"`
	Stream  LogStream   `db:"stream" json:"Stream"`
	Message string      `db:"message" json:"Message"`
}

// InsertYtdlpLog
//
//	INSERT INTO ytdlp_logs (job_id, stream, message)
//	VALUES ($1, $2, $3)
func (q *Queries) InsertYtdlpLog(ctx context.Context, arg *InsertYtdlpLogParams) error {
	_, err := q.db.Exec(ctx, insertYtdlpLog, arg.JobID, arg.Stream, arg.Message)
	return err
}
