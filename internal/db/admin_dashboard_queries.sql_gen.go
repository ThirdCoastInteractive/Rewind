// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: admin_dashboard_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getDashboardOverview = `-- name: GetDashboardOverview :one

SELECT
    (SELECT COUNT(*)::bigint FROM videos) AS total_videos,
    (SELECT COUNT(*)::bigint FROM clips) AS total_clips,
    (SELECT COUNT(*)::bigint FROM markers) AS total_markers,
    (SELECT COUNT(*)::bigint FROM users WHERE deleted_at IS NULL) AS total_users,
    (SELECT COUNT(*)::bigint FROM video_comments) AS total_comments,
    (SELECT COALESCE(SUM(file_size), 0)::bigint FROM videos WHERE file_size IS NOT NULL) AS total_storage_bytes,
    (SELECT COALESCE(SUM(duration_seconds), 0)::bigint FROM videos WHERE duration_seconds IS NOT NULL) AS total_duration_seconds
`

type GetDashboardOverviewRow struct {
	TotalVideos          int64 `db:"total_videos" json:"TotalVideos"`
	TotalClips           int64 `db:"total_clips" json:"TotalClips"`
	TotalMarkers         int64 `db:"total_markers" json:"TotalMarkers"`
	TotalUsers           int64 `db:"total_users" json:"TotalUsers"`
	TotalComments        int64 `db:"total_comments" json:"TotalComments"`
	TotalStorageBytes    int64 `db:"total_storage_bytes" json:"TotalStorageBytes"`
	TotalDurationSeconds int64 `db:"total_duration_seconds" json:"TotalDurationSeconds"`
}

// ============================================================================
// Admin Dashboard Metrics
// ============================================================================
// GetDashboardOverview returns high-level counts and totals for the admin dashboard.
//
//	SELECT
//	    (SELECT COUNT(*)::bigint FROM videos) AS total_videos,
//	    (SELECT COUNT(*)::bigint FROM clips) AS total_clips,
//	    (SELECT COUNT(*)::bigint FROM markers) AS total_markers,
//	    (SELECT COUNT(*)::bigint FROM users WHERE deleted_at IS NULL) AS total_users,
//	    (SELECT COUNT(*)::bigint FROM video_comments) AS total_comments,
//	    (SELECT COALESCE(SUM(file_size), 0)::bigint FROM videos WHERE file_size IS NOT NULL) AS total_storage_bytes,
//	    (SELECT COALESCE(SUM(duration_seconds), 0)::bigint FROM videos WHERE duration_seconds IS NOT NULL) AS total_duration_seconds
func (q *Queries) GetDashboardOverview(ctx context.Context) (*GetDashboardOverviewRow, error) {
	row := q.db.QueryRow(ctx, getDashboardOverview)
	var i GetDashboardOverviewRow
	err := row.Scan(
		&i.TotalVideos,
		&i.TotalClips,
		&i.TotalMarkers,
		&i.TotalUsers,
		&i.TotalComments,
		&i.TotalStorageBytes,
		&i.TotalDurationSeconds,
	)
	return &i, err
}

const getJobStatusCounts = `-- name: GetJobStatusCounts :many
SELECT
    'download' AS job_type,
    status::text AS status,
    COUNT(*)::bigint AS count
FROM download_jobs
GROUP BY status
UNION ALL
SELECT
    'ingest' AS job_type,
    status::text AS status,
    COUNT(*)::bigint AS count
FROM ingest_jobs
GROUP BY status
ORDER BY job_type, status
`

type GetJobStatusCountsRow struct {
	JobType string `db:"job_type" json:"JobType"`
	Status  string `db:"status" json:"Status"`
	Count   int64  `db:"count" json:"Count"`
}

// GetJobStatusCounts returns download and ingest job counts grouped by status.
//
//	SELECT
//	    'download' AS job_type,
//	    status::text AS status,
//	    COUNT(*)::bigint AS count
//	FROM download_jobs
//	GROUP BY status
//	UNION ALL
//	SELECT
//	    'ingest' AS job_type,
//	    status::text AS status,
//	    COUNT(*)::bigint AS count
//	FROM ingest_jobs
//	GROUP BY status
//	ORDER BY job_type, status
func (q *Queries) GetJobStatusCounts(ctx context.Context) ([]*GetJobStatusCountsRow, error) {
	rows, err := q.db.Query(ctx, getJobStatusCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetJobStatusCountsRow
	for rows.Next() {
		var i GetJobStatusCountsRow
		if err := rows.Scan(&i.JobType, &i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStorageByUploader = `-- name: GetStorageByUploader :many
SELECT
    (CASE WHEN uploader = '' THEN 'unknown' ELSE uploader END)::text AS uploader,
    COALESCE(SUM(file_size), 0)::bigint AS total_bytes
FROM videos
WHERE file_size IS NOT NULL
GROUP BY uploader
ORDER BY total_bytes DESC
LIMIT 10
`

type GetStorageByUploaderRow struct {
	Uploader   string `db:"uploader" json:"Uploader"`
	TotalBytes int64  `db:"total_bytes" json:"TotalBytes"`
}

// GetStorageByUploader returns total file storage grouped by uploader.
//
//	SELECT
//	    (CASE WHEN uploader = '' THEN 'unknown' ELSE uploader END)::text AS uploader,
//	    COALESCE(SUM(file_size), 0)::bigint AS total_bytes
//	FROM videos
//	WHERE file_size IS NOT NULL
//	GROUP BY uploader
//	ORDER BY total_bytes DESC
//	LIMIT 10
func (q *Queries) GetStorageByUploader(ctx context.Context) ([]*GetStorageByUploaderRow, error) {
	rows, err := q.db.Query(ctx, getStorageByUploader)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetStorageByUploaderRow
	for rows.Next() {
		var i GetStorageByUploaderRow
		if err := rows.Scan(&i.Uploader, &i.TotalBytes); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopSources = `-- name: GetTopSources :many
SELECT
    COALESCE(
        regexp_replace(src, 'https?://(?:www\.)?([^/]+).*', '\1'),
        'unknown'
    )::text AS source,
    COUNT(*)::bigint AS count
FROM videos
GROUP BY source
ORDER BY count DESC
LIMIT 10
`

type GetTopSourcesRow struct {
	Source string `db:"source" json:"Source"`
	Count  int64  `db:"count" json:"Count"`
}

// GetTopSources returns the top video sources (platforms) by count.
//
//	SELECT
//	    COALESCE(
//	        regexp_replace(src, 'https?://(?:www\.)?([^/]+).*', '\1'),
//	        'unknown'
//	    )::text AS source,
//	    COUNT(*)::bigint AS count
//	FROM videos
//	GROUP BY source
//	ORDER BY count DESC
//	LIMIT 10
func (q *Queries) GetTopSources(ctx context.Context) ([]*GetTopSourcesRow, error) {
	rows, err := q.db.Query(ctx, getTopSources)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTopSourcesRow
	for rows.Next() {
		var i GetTopSourcesRow
		if err := rows.Scan(&i.Source, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVideosPerDay = `-- name: GetVideosPerDay :many
SELECT
    d.day::date AS day,
    COUNT(v.id)::bigint AS count
FROM generate_series(
    CURRENT_DATE - ($1::int - 1) * INTERVAL '1 day',
    CURRENT_DATE,
    '1 day'
) AS d(day)
LEFT JOIN videos v ON v.created_at::date = d.day::date
GROUP BY d.day
ORDER BY d.day
`

type GetVideosPerDayRow struct {
	Day   pgtype.Date `db:"day" json:"Day"`
	Count int64       `db:"count" json:"Count"`
}

// GetVideosPerDay returns the number of videos archived per day for the last N days.
//
//	SELECT
//	    d.day::date AS day,
//	    COUNT(v.id)::bigint AS count
//	FROM generate_series(
//	    CURRENT_DATE - ($1::int - 1) * INTERVAL '1 day',
//	    CURRENT_DATE,
//	    '1 day'
//	) AS d(day)
//	LEFT JOIN videos v ON v.created_at::date = d.day::date
//	GROUP BY d.day
//	ORDER BY d.day
func (q *Queries) GetVideosPerDay(ctx context.Context, days int32) ([]*GetVideosPerDayRow, error) {
	rows, err := q.db.Query(ctx, getVideosPerDay, days)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetVideosPerDayRow
	for rows.Next() {
		var i GetVideosPerDayRow
		if err := rows.Scan(&i.Day, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
